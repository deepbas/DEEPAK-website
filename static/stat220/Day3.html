<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Objects in R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Bastola" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="libs/font-awesome/css/all.min.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.min.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <script src="https://use.fontawesome.com/5235085b15.js"></script>

    <link rel="stylesheet" href="css/xaringan-themer-solns.css" type="text/css" />
    <link rel="stylesheet" href="css/my-theme.css" type="text/css" />
    <link rel="stylesheet" href="css/my-font.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">








layout: true
  
---

class: title-slide, middle

# .fancy[Data Objects in R]

### .fancy[Spring 23]

 January 07 2024

---


class: middle

#  Object Oriented Programming in R

.bql.font90[

- R uses object-oriented programming (OOP) principles
- Functions in R are designed to work with specific object classes and types
- Example: `plot()` function behaves differently based on the input object

]


---

# `plot()` Function Examples

Scatterplot with `plot()`:


```r
plot(y ~ x, data = mydata)  # If x and y are numeric, creates a scatterplot
```

--

Diagnostic plots with `plot()`:


```r
my_lm &lt;- lm(y ~ x, data = mydata)  # Create a linear model
plot(my_lm)  # Produces diagnostic plots for the linear model
```


.bq.font90[
- The `plot()` function adapts its behavior based on the input object's class and type
- This allows for efficient and intuitive coding in R
]

---

class: middle

# Data structures and types in R



.bq.font90[

- R objects are based on vectors

- Two functions to examine objects:

  - `typeof()`: Returns the storage mode (data type) of an object
  - `class()`: Provides further description of an object
  
- NULL: Represents an empty object (vector of length 0)
]

 

---

class: middle

#  Examples of Data Types and Functions

.pull-left[
Numeric and integer data types:



```r
x &lt;- c(8, 2, 1, 3)
typeof(x)  # "double" (numeric)
[1] "double"

x_int &lt;- c(8L, 2L, 1L, 3L)
typeof(x_int)  # "integer"
[1] "integer"
```

]


.pull-right[
Logical data type and class:



```r
x_is_one &lt;- x == 1
typeof(x_is_one)  # "logical"
[1] "logical"

object_class &lt;- class(x)
object_class  # "numeric"
[1] "numeric"
```

]



---



class: middle

# Atomic Vectors and lists


.pull-left[
&lt;br&gt;
.bq.font90[
- R uses two types of vectors to store info

    - **atomic vectors**: all entries have the same data type 
    - **lists**: entries can contain other objects that can differ in data type
]    
]

.pull-right[

&lt;img src="images/atomic_vectors.png" width="110%" height="110%"&gt; &lt;br&gt;

]

---

class: middle

# Examples of Vector Types

.bq[
Atomic vector (numeric):


```r
atomic_vector &lt;- c(1, 2, 3, 4)
class(atomic_vector)  # "numeric"
[1] "numeric"
```

]

.bq[
List with multiple data types:

```r
my_list &lt;- list(name = "John", age = 30, salary = 50000)
class(my_list)  # "list"
[1] "list"
```


]


---

class: middle


# Atomic Vectors: Matrices

.bq.font90[
- You can add **attributes**, such as **dimension**, to vectors
- A **matrix** is a 2-dimensional vector containing entries of the same type
]

.pull-left[Creating a matrix with dimensions:

```r
my_matrix &lt;- matrix(1:9, nrow = 3, ncol = 3)
class(my_matrix)  # "matrix"
[1] "matrix" "array" 
my_matrix
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
typeof(my_matrix)
[1] "integer"
```

]
.pull-right[Adding dimensions to a vector:

```r
my_vector &lt;- c(1, 2, 3, 4, 5, 6)
dim(my_vector) &lt;- c(2, 3)
my_vector
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
class(my_vector)
[1] "matrix" "array" 
typeof(my_vector)
[1] "double"
```

]



---

class: middle

# Creating Matrices Using Vector Binding

.bq.font80[
- Bind vectors of the same length to create columns or rows
- Use `cbind()` for column binding and `rbind()` for row binding
]

.pull-left[Column binding with `cbind()`:


```r
x &lt;- c(1, 2, 3, 4)
x_col &lt;- cbind(x = x, y = 2 * x)
x_col
     x y
[1,] 1 2
[2,] 2 4
[3,] 3 6
[4,] 4 8
```

]

.pull-right[Row binding with `rbind()`:


```r
x_row &lt;- rbind(x1 = x, x2 = x * 2)
x_row
   [,1] [,2] [,3] [,4]
x1    1    2    3    4
x2    2    4    6    8
```


]

---

class: middle

# Implicit and Explicit Coercion in R

.pull-left[
## Implicit Coercion 

.bq.font90[
- R defaults to the most complex data type if more than one type is given
]


```r
y &lt;- c(1, 2, "a", NULL, TRUE)
typeof(y)
[1] "character"
class(y)
[1] "character"
y
[1] "1"    "2"    "a"    "TRUE"
```

]


.pull-right[

## Explicit coercion


.bq.font90[Intentionally force a different data type from the "default" type]


```r
y &lt;- as.character(c(1, 2, "a", NULL, TRUE))
typeof(y)
[1] "character"
class(y)
[1] "character"
y
[1] "1"    "2"    "a"    "TRUE"
```

]

---

class: middle

# Logical Vectors coercion

.bql[Logical values coerced into 0 for .b[FALSE] and 1 for .b[TRUE] when applying math functions]


```r
x &lt;- c(8, 2, 1, 3)
x &gt;= 5  # which entries &gt;= 5?
[1]  TRUE FALSE FALSE FALSE
sum(x &gt;= 5)  # how many &gt;= 5?
[1] 1
```

- Mean of a Logical Vector


```r
mean(x &gt;= 5) 
[1] 0.25
```

---

class: middle

# Examples: Coercion of Logical Values

.pull-left[
Sum of Logical Values

```r
grades &lt;- c(80, 60, 95, 70, 85)
passing_grades &lt;- grades &gt;= 65
sum(passing_grades)  # count of passing grades
[1] 4
```


]

.pull-right[
Mean of Logical Values

```r
rainfall &lt;- c(1.2, 0, 2.5, 0.8, 0, 0)
rainy_days &lt;- rainfall &gt; 0
mean(rainy_days)  # proportion of rainy days
[1] 0.5
```


]

---

# Data types: factors 

- Factors are a class of data that are stored as **integers**

.code80[

```r
x_fct &lt;- as.factor(c("yes", "no", "no"))
class(x_fct)
[1] "factor"
typeof(x_fct)
[1] "integer"
```
]

--

.bq.font80[The attribute `levels` is a character vector of possible values
  - Values are stored as the integers (1=first `level`, 2=second `level`, etc.)
  - Levels are ordered alphabetically/numerically (unless specified otherwise)
]
    
--


```r
str(x_fct)
 Factor w/ 2 levels "no","yes": 2 1 1
levels(x_fct)
[1] "no"  "yes"
```
---

# Subsetting: Atomic Vector and Matrices


- subset with `[]` by referencing index value (from 1 to vector length):


```r
x
[1] 8 2 1 3
x[c(4, 2)]  # get 4th and 2nd entries
[1] 3 2
```

- subset by omitting entries


```r
x[-c(4, 2)]  # omit 4th and 2nd entries
[1] 8 1
```

- subset with a logical vector


```r
# get 1st and 3rd entries
x[c(TRUE, FALSE, TRUE, FALSE)]
[1] 8 1
```


---

class: middle

# Subsetting: Matrices

- Access entries using subsetting `[row,column]`

.pull-left[

```r
x_col
     x y
[1,] 1 2
[2,] 2 4
[3,] 3 6
[4,] 4 8
```
]
.pull-right[



```r
x_col[, 1] # first column
[1] 1 2 3 4
```




```r
x_col[1:2, 1] # first 2 rows of first column
[1] 1 2
```
]

.blue-h[R Doesn't Always Preserve Class]


```r
# one row (or col) is no longer a matrix (1D)
class(x_col[1,])  
[1] "numeric"
```



---

# Subsetting: Atomic Vector and Matrices

- You can access entries like a matrix:

.pull-left[

```r
x_df &lt;- data.frame(x = x, double_x = x*2)
x_df
  x double_x
1 8       16
2 2        4
3 1        2
4 3        6
```
]

.pull-right[


```r
x_df[, 1]  # first column, all rows
[1] 8 2 1 3
```

]


--

 or access columns with `$`


```r
x_df$x  # get variable x column
[1] 8 2 1 3
```



```r
# first column is no longer a dataframe
class(x_df[, 1])  
[1] "numeric"
```



---

class: middle

# Data frames or Tibbles


.bq.font80[
### Tibbles
- are a new modern data frame

- never changes the input data types

- can have columns that are lists

- can have non-standard variable names

  - can start with a number or contain spaces
]


---

class: middle

# Subsetting data frames



- Can also use column names to subset:


```r
library(babynames)
# get 2 rows of Name and Sex
babynames[1:2, c("name", "sex")] 
# A tibble: 2 Ã— 2
  name  sex  
  &lt;chr&gt; &lt;chr&gt;
1 Mary  F    
2 Anna  F    
```



---

# Lists in R

.pull-left-60[
## Lists: Flexible Data Containers
- List is a vector with entries that can be different object types


```r
my_list &lt;- list(myVec = x, 
                myDf = x_df, 
                myString = c("hi", "bye"))
my_list
$myVec
[1] 8 2 1 3

$myDf
  x double_x
1 8       16
2 2        4
3 1        2
4 3        6

$myString
[1] "hi"  "bye"
```


]

.pull-right-40[
## Accessing List Elements
- Like a data frame, use the $ to access named objects stored in the list


```r
my_list$myDf
  x double_x
1 8       16
2 2        4
3 1        2
4 3        6
```


```r
class(my_list$myDf)
[1] "data.frame"
```


]

---

# Subsetting Lists with Single Brackets


.bq.font80[
- One `[]` operator gives you the object at the given location but preserves the list type
- `my_list[2]` returns a list of length one with entry `myDf`]


```r
my_list[2]
$myDf
  x double_x
1 8       16
2 2        4
3 1        2
4 3        6
```



```r
str(my_list[2])
List of 1
 $ myDf:'data.frame':	4 obs. of  2 variables:
  ..$ x       : num [1:4] 8 2 1 3
  ..$ double_x: num [1:4] 16 4 2 6
```

---

class: middle

# Subsetting Lists with Double Brackets

.bq.font80[
- The double `[[]]` operator gives you the object stored at that location (equivalent to using $)
- `my_list[[2]]` or `my_list[["myDf"]]` return the data frame `myDf`]



```r
my_list[[2]]
  x double_x
1 8       16
2 2        4
3 1        2
4 3        6
str(my_list[[2]])
'data.frame':	4 obs. of  2 variables:
 $ x       : num  8 2 1 3
 $ double_x: num  16 4 2 6
```


---

class: middle

# List Subsetting Recap

.bql[
- Single brackets `[]` preserve the list type
- Double brackets `[[]]` return the object stored at the location
- Use `$` to access named objects in a list
]


---

class: action, middle

# &lt;i class="fa fa-pencil-square-o" style="font-size:48px;color:purple"&gt;&amp;nbsp;Group&amp;nbsp;Activity&amp;nbsp;1&lt;/i&gt;    


.pull-left-40[
![](https://media.giphy.com/media/RKApDdwsQ6jkwd6RNn/giphy.gif)
]
.pull-right-60[
&lt;br&gt;
.bq.font80[
- Let's go over to maize server/ local Rstudio and our class [moodle](https://moodle.carleton.edu/course/view.php?id=41417)
- Get the class activity 3 file
- Please work on the problems 
- Talk to your neighbor or ask me questions
]
]

<div class="countdown" id="timer_975f7bb0" data-update-every="1" tabindex="0" style="top:0;right:0;padding:3px 4px;font-size:2em;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"highlightLanguage": ["r", "css", "yaml"],
"countIncrementalSlides": true,
"slideNumberFormat": "%current%",
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
