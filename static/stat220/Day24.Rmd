---
title: "Intro to Clustering"
subtitle: "<br/> Spring 2023"
author: "Bastola"
date: "`r format(Sys.Date(), ' %B %d %Y')`"
output:
  xaringan::moon_reader:
    css: ["default", css/xaringan-themer-solns.css, css/my-theme.css, css/my-font.css]
    lib_dir: libs
    chakra: libs/remark-latest.min.js
    seal: false
    nature:
      highlightStyle: googlecode  #http://arm.rbind.io/slides/xaringan.html#77 # idea, magula
      highlightLines: true
      highlightLanguage: ["r", "css", "yaml"]
      countIncrementalSlides: true
      slideNumberFormat: "%current%"
      titleSlideClass: ["left", "middle", "inverse"]
      ratio: "16:9"
    includes:
      in_header: header.html
editor_options: 
  chunk_output_type: console
header-includes:
    - \usepackage{caption}
---


```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
options(htmltools.preserve.raw = FALSE)
options(ggrepel.max.overlaps = Inf)

knitr::opts_chunk$set(echo = TRUE, 
                      dev = 'svg',
                      collapse = TRUE, 
                      comment = NA,  # PRINTS IN FRONT OF OUTPUT, default is '##' which comments out output
                      prompt = FALSE, # IF TRUE adds a > before each code input
                      warning = FALSE, 
                      message = FALSE,
                      fig.height = 3, 
                      fig.width = 4,
                      out.width = "100%",
                      prompt = FALSE,
                      rows.print=7
                      )



# load necessary packages
library(tidyr)
library(dplyr)
library(ggplot2)
library(countdown)
library(ggthemes)
library(tidyverse)
library(stringr)
library(xaringanExtra)
xaringanExtra::use_panelset()
xaringanExtra::use_tachyons()
library(flipbookr)
library(htmlwidgets)
library(lubridate)
library(palmerpenguins)
library(fontawesome)
library(class)
library(patchwork)
library(tidymodels)
library(mlbench)     # for PimaIndiansDiabetes2 dataset
library(janitor)
library(parsnip)
library(kknn)
library(paletteer)
library(corrr)
library(scico)
library(gridExtra)
library(factoextra)


select <- dplyr::select

# Set ggplot theme
# theme_set(theme_stata(base_size = 10))

yt <- 0

USAData <- as_tibble(USArrests, rownames = "state") %>% drop_na() %>%
  column_to_rownames("state")


standardize <- function(x, na.rm = FALSE) {
  (x - mean(x, na.rm = na.rm)) / sd(x, na.rm = na.rm)
}

set.seed(233)

clus_df <- tibble(
  x1 = rnorm(n = 150, mean = rep(c(5,7,8), each = 50)),
  x2 = rnorm(n = 150, mean = rep(c(2, 5, 1), each = 50)),
  y = unlist(lapply(1:3, function(x) rep(as.character(x),50)))
)


my_df <- tibble(
  X1 = rnorm(n = 50, mean = rep(c(1, 3), each = 25)),
  X2 = rnorm(n = 50, mean = rep(c(1.3, 1), each = 25))
)

multi_kmeans <- tibble(k = 1:10) %>%
  mutate(
    model = purrr::map(k, ~ kmeans(my_df, centers = .x, nstart = 25)),
    tot.withinss = purrr::map_dbl(model, ~ glance(.x)$tot.withinss)
  )

d2 <- dist(my_df, method = "euclidean")
hc2 <- hclust(d2)
```




```{r xaringanExtra-clipboard, echo=FALSE}
htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa fa-clipboard\"></i>",
    success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
    error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```


layout: true
  
---

class: title-slide, middle

# .fancy[Intro to Clustering]

### .fancy[Spring 2023]

`r format(Sys.Date(), ' %B %d %Y')`

---

# Supervised learning

<center>
<img src="images/supervised-machine-learning.png" width="60%" height="60%"> <br>
</center>


.bql.font80[
- train or "supervise" algorithms to use labels to classify data or predict outcomes

- use labeled inputs and outputs to measure model accuracy  
]


.footnote[Image source: click [here](https://www.javatpoint.com/supervised-machine-learning)]

---

class: middle

# Unsupervised learning

<center>
<img src="images/unsupervised.jpg" width="70%" height="70%"> <br>
</center>


.bql.font60[

- uses statistical learning algorithms to analyze and cluster unlabeled data sets 

- discover hidden patterns in data without human intervention, so "unsupervised"

  - group unlabeled data based on their similarities or differences

]



.footnote[Image source: click [here](https://www.geeksforgeeks.org/clustering-in-machine-learning/)]

---

# Example: get cluster association from unlabeled data

```{r, echo=FALSE}
clus_df_left <- clus_df %>% select(-y)
```


.pull-left[
```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width="100%"}

ggplot(clus_df_left, aes(x = x1, y = x2)) + 
  geom_point() +
  coord_fixed() +
  theme_tufte()
```

]
.pull-right[
```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width="100%"}
ggplot(clus_df, aes(x = x1, y = x2, color = y, shape = y)) + 
  geom_point() +
  coord_fixed() +
  scale_color_fivethirtyeight() +
  theme_tufte() +
  theme(legend.position = "none") 

```

]

```{r, echo=FALSE}
clus_df <- clus_df %>% select(-y)
```

--
<div style="position: absolute; top: 10%; left: 10%;">
<span style="content: '\2192'; font-size: 40px; color: #FF00FF; text-align: center; white-space: pre-line;">
  <p style="font-family: 'Comic Sans MS', cursive, sans-serif; font-weight: bold;">No labels!</p>
</span>
</div>


--

<div style="position: absolute; top: 10%; left: 60%;">
<span style="content: '\2192'; font-size: 40px; color: #FF00FF; text-align: center; white-space: pre-line;">
  <p style="font-family: 'Comic Sans MS', cursive, sans-serif; font-weight: bold;">Labels!!</p>
</span>
</div>



--

.bold[Can use an unsupervised algorithm called k-means to achieve this!]

---


class: middle

# K-means Basics

.bq[
- Algorithm to group data into K clusters

- Starts with an initial clustering of data

- Iteratively improves the cluster assignments 

- Stops until the assignments cannot be improved further
]

---

class: middle

# Algorithm

.bq[
1. Randomly assign a number, from 1 to K, to each of the observations

2. Compute the centroid of each of the K clusters

3. Assign each point to the nearest centroid and redefine the cluster

4. Repeat steps 2 and 3 until no point change clusters
]

---

# Main Idea

.out-t[To minimize the total within cluster variation]

<br>

.bq.font80[
The total within-cluster variation is the sum of squared Euclidean distances between items and the corresponding centroid:

$$WSS = \sum_{k=1}^K WSS(C_k) = \sum_{k=1}^K \sum_{x_i \in C_k}(x_i - \mu_k)^2$$
where:
- WSS is the Within Cluster Sum of Squared Errors 
- $x_i$ is a data point in the cluster $C_k$
- $\mu_k$ is the mean value of the points assigned to the cluster $C_k$
]

---

.bold[(1). Randomly assign a number, from 1 to *K* , to each of the observations]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
set.seed(77)
clus_df <- clus_df %>% 
  mutate(cluster_assign = as.character(sample(as.character(1:3), 150, replace=TRUE)))
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() + 
  scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") + 
  theme_tufte()
```


---

.bold[(2). Compute the centroid of each cluster]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
centroids <- clus_df %>% 
  group_by(cluster_assign) %>%
  summarize_all(mean)
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign), pch="X", size=4, show.legend=FALSE) + 
  scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") + 
  theme_tufte()
```


---

.bold[(3). Re-assign each observation to the cluster whose centroid is closest]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
distance <- as.matrix(dist(rbind(select(centroids, -cluster_assign), select(clus_df, -cluster_assign))))
distance <- distance[4:153,1:3]
min_dist <- as.vector(apply(distance,1,min))
new_cluster <- sapply(1:150, function(x) which(distance[x,] == min_dist[x]))
clus_df <- clus_df %>% mutate(cluster_assign =as.character(new_cluster))
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign), pch="X", size=4, show.legend=FALSE)+ 
  scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") +
  theme_tufte()
```

---

.bold[(4). Re-compute the centroid of each cluster]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
centroids <- clus_df %>% 
  group_by(cluster_assign) %>%
  summarize_all(mean)
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign),pch="X", size=4, show.legend=FALSE) + 
 scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") +
  theme_tufte()
```


---

.bold[(5). Re-assign each observation to the cluster whose centroid is closest]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
distance <- as.matrix(dist(rbind(select(centroids, -cluster_assign), select(clus_df, -cluster_assign))))
distance <- distance[4:153,1:3]
min_dist <- as.vector(apply(distance,1,min))
new_cluster <- sapply(1:150, function(x) which(distance[x,] == min_dist[x]))
clus_df <- clus_df %>% mutate( cluster_assign =as.character(new_cluster))
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign),pch="X", size=4, show.legend=FALSE) + 
  scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") +
  theme_tufte()
```


---

.bold[(6). Re-compute the centroid of each cluster]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
centroids <- clus_df %>% 
  group_by(cluster_assign) %>%
  summarize_all(mean)
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign),pch="X", size=4, show.legend=FALSE) + 
 scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") +
  theme_tufte()
```


---

.bold[(7). Re-assign each observation to the cluster whose centroid is closest]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
distance <- as.matrix(dist(rbind(select(centroids, -cluster_assign), select(clus_df, -cluster_assign))))
distance <- distance[4:153,1:3]
min_dist <- as.vector(apply(distance,1,min))
new_cluster <- sapply(1:150, function(x) which(distance[x,] == min_dist[x]))
clus_df <- clus_df %>% mutate( cluster_assign =as.character(new_cluster))
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign),pch="X", size=4, show.legend=FALSE) + 
  scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") +
  theme_tufte()
```


---

.bold[(8). Re-compute the centroid of each cluster]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
centroids <- clus_df %>% 
  group_by(cluster_assign) %>%
  summarize_all(mean)
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign),pch="X", size=4, show.legend=FALSE) + 
 scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") +
  theme_tufte()
```


---

.bold[(9). Re-assign each observation to the cluster whose centroid is closest]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
distance <- as.matrix(dist(rbind(select(centroids, -cluster_assign), select(clus_df, -cluster_assign))))
distance <- distance[4:153,1:3]
min_dist <- as.vector(apply(distance,1,min))
new_cluster <- sapply(1:150, function(x) which(distance[x,] == min_dist[x]))
clus_df <- clus_df %>% mutate( cluster_assign =as.character(new_cluster))
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign),pch="X", size=4, show.legend=FALSE) + 
  scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") +
  theme_tufte()
```


---

.bold[(10). Re-compute the centroid of each cluster]

```{r, echo=FALSE, fig.height = 4, fig.width = 4.5, fig.align='center', out.width=600, warning=FALSE}
centroids <- clus_df %>% 
  group_by(cluster_assign) %>%
  summarize_all(mean)
ggplot(clus_df, aes(x=x1,y=x2, color=cluster_assign, shape=cluster_assign)) + 
  geom_point()+
  coord_fixed() +
  geom_point(data=centroids, aes(x=x1,y=x2, color=cluster_assign),pch="X", size=4, show.legend=FALSE) + 
 scale_color_fivethirtyeight("cluster") +
  scale_shape_discrete("cluster") +
  theme_tufte()
```

---

class: middle

# `USArrests`

```{r}
USAData <- as_tibble(USArrests, rownames = "state") %>% drop_na() %>%
  column_to_rownames("state") %>%
  select(Murder, UrbanPop)
```

```{r}
head(USAData, 10)
```

---

class: middle

# Means and standard deviations


```{r}
USAData %>%
  map_dfr(mean)
```



```{r}
USAData %>%
  map_dfr(sd)
```


---

class: middle

# Standardize the data

<!-- Don't want the clustering algorithm to depend to an arbitrary variable unit -->

```{r}
USAData <- USAData %>% mutate(across(where(is.numeric), standardize))
```

```{r}
head(USAData,10)
```



---

class: inverse, middle

# .center.bql.Large[So, how do we fit all of this in R?]

---

class: middle

# `kmeans()`

.bql.font90[
- `kmeans()` function takes a matrix or data-frame or tibble and the number of centers/clusters we want to find.

- We also set `nstart = 20-25` to have multiple initial starting positions in the hope of finding global optimal solution instead of local optimal solution

- Use `set.seed()` for reproducibility
]

---

class: middle

# Within Cluster Sum of Squared Errors (WSS)

.bq.font90[
- Calculate WSS for different values of K.

- Choose K for which WSS first starts to diminish.

- Visually deciphered with an .bold[elbow graph].

- The number of clusters is taken at the elbow joint point.
]

---

class: middle

# K-means


```{r}
set.seed(1234)
k.means <- kmeans(USAData, centers = 2, nstart = 25)
```


---

# `k.means`

```{r}
k.means
```



---

class: middle

# Tidy the information


```{r}
k.means %>% broom::tidy()
```


---

class: middle

# `Glance` at the sum of square decompositions


```{r}
glance(k.means)
```


---

class: middle

# `augment` from `broom` package

.scroll-box-20[
```{r}
knitr::kable(broom::augment(k.means, data = USAData))
```
]

---

```{r, echo=FALSE, fig.width=8, fig.height=6, fig.align='center', out.width = "75%" }
set.seed(1234)
USAData %>%
  mutate(cluster = k.means$cluster,
         state = row.names(USAData)) %>%
  ggplot(aes(y = UrbanPop, x = Murder, color = factor(cluster), label = state)) +
  ggrepel::geom_text_repel() + scale_color_discrete(name="cluster") +
  theme_stata()
```

---

# In-built function for visuals using `factoextra`

.code80[
```{r, fig.width=8, fig.height=6, fig.align='center', out.width = "55%"}
library(factoextra)
fviz_cluster(k.means, data = USAData, repel = TRUE, ggtheme = theme_tufte())
```
]

---

```{r, echo=FALSE, fig.width=8, fig.height=6, fig.align='center', out.width = "75%"}
k.means1 <- k.means
k.means2 <- kmeans(USAData, centers = 3, nstart = 25)
k.means3 <- kmeans(USAData, centers = 4, nstart = 25)
k.means4 <- kmeans(USAData, centers = 5, nstart = 25)

# plots to compare
p1 <- fviz_cluster(k.means1, geom = "point", data = USAData, ggtheme = theme_tufte()) + ggtitle("k = 2")
p2 <- fviz_cluster(k.means2, geom = "point",  data = USAData, ggtheme = theme_tufte()) + ggtitle("k = 3")
p3 <- fviz_cluster(k.means3, geom = "point",  data = USAData, ggtheme = theme_tufte()) + ggtitle("k = 4")
p4 <- fviz_cluster(k.means4, geom = "point",  data = USAData, ggtheme = theme_tufte()) + ggtitle("k = 5")

library(gridExtra)
grid.arrange(p1, p2, p3, p4, nrow = 2)
```


---


class: action, middle

# <i class="fa fa-pencil-square-o" style="font-size:48px;color:purple">&nbsp;Group&nbsp;Activity&nbsp;`r (yt <- yt + 1)`</i>    


.pull-left-40[
![](https://media.giphy.com/media/RKApDdwsQ6jkwd6RNn/giphy.gif)
]
.pull-right-60[
<br>
<br>
.bq[
- Get the class activity 24.Rmd file from  [moodle](https://moodle.carleton.edu/course/view.php?id=41417) 
- Let's work on group activity 1 together
]



]

`r countdown(minutes = 10, seconds = 00, top = 0 , color_background = "inherit", padding = "3px 4px", font_size = "2em")`


---


class: middle, inverse

# .red[Visuals do not tell all the story]

.bqt[Visuals tell us where the true delineations occur, but do not tell us what the optimal number of clusters is.]


---


# Determine the optimal number of clusters


```{r}
set.seed(1234)
multi_kmeans <- tibble(k = 1:10) %>%
  mutate(
    model = purrr::map(k, ~ kmeans(USAData, centers = .x, nstart = 25)), #<<
    tot.withinss = purrr::map_dbl(model, ~ glance(.x)$tot.withinss) 
  )

multi_kmeans
```


---

# Determine the optimal number of clusters


```{r}
set.seed(1234)
multi_kmeans <- tibble(k = 1:10) %>%
  mutate(
    model = purrr::map(k, ~ kmeans(USAData, centers = .x, nstart = 25)),
    tot.withinss = purrr::map_dbl(model, ~ glance(.x)$tot.withinss) #<<
  )

multi_kmeans
```


---

```{r, echo=FALSE, echo=FALSE, fig.width=8, fig.height=6, fig.align='center', out.width = "75%"}
multi_kmeans %>%
  ggplot(aes(k, tot.withinss)) +
  geom_point() +
  geom_line() +
  annotate("text", x = multi_kmeans$k[5] + 1, 
           y = multi_kmeans$tot.withinss[5] + 15, 
           label = "Elbow", size = 5) +
  
  annotate("segment", x = multi_kmeans$k[5] + 0.5, y = multi_kmeans$tot.withinss[5] + 15, 
                 xend = multi_kmeans$k[5], yend = multi_kmeans$tot.withinss[5], colour = "blue", size = 1, arrow = arrow(length = unit(.4,"cm"))) +
  theme_light()+
  xlab("K") +
  ylab("Total within-cluster sum of squares")+
  scale_x_continuous(breaks = 1:15) +
  theme(panel.grid.minor.x = element_blank())
```

---

```{r, echo=FALSE, fig.width=8, fig.height=6, fig.align='center', out.width = "75%"}
set.seed(1234)
kmeans.final <- kmeans(USAData, 5, nstart = 25)
fviz_cluster(kmeans.final, data = USAData, repel = TRUE, ggtheme = theme_tufte())
```

---

class: middle

# Extract the centroids

.code140[
```{r}
USAData %>%
  mutate(Cluster = kmeans.final$cluster) %>%
  group_by(Cluster) %>%
  summarise_all("mean")
```
]


---

class: action, middle

# <i class="fa fa-pencil-square-o" style="font-size:48px;color:purple">&nbsp;Group&nbsp;Activity&nbsp;`r (yt <- yt + 1)`</i>    


.pull-left-40[
![](https://media.giphy.com/media/RKApDdwsQ6jkwd6RNn/giphy.gif)
]
.pull-right-60[
<br>
<br>
<br>
.bq[
- Please continue working on the remainder of the group activities
]

]

`r countdown(minutes = 10, seconds = 00, top = 0 , color_background = "inherit", padding = "3px 4px", font_size = "2em")`


