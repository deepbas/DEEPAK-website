<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data wrangling with dplyr</title>
    <meta charset="utf-8" />
    <meta name="author" content="Bastola" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="libs/panelset-0.2.6/panelset.js"></script>
    <link href="libs/countdown-0.3.5/countdown.css" rel="stylesheet" />
    <script src="libs/countdown-0.3.5/countdown.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, top, my-title, title-slide

# Data wrangling with <strong>dplyr</strong>
## <br/> STAT 220
### Bastola
### January 17 2022

---


&lt;style type="text/css"&gt;

.hljs-github .hljs {
    background: #e5e5e5;
}

.inline-c, remark-inline-code {
   background: #e5e5e5;
   border-radius: 3px;
   padding: 4px;
   font-family: 'Source Code Pro', 'Lucida Console', Monaco, monospace;
}

.yellow-h{
   background: #ffff88;
}

.out-t, remark-inline-code {
   background: #9fff9f;
   border-radius: 3px;
   padding: 4px;
   
}

.pull-left-c {
    float: left;
    width: 58%;
    
}

.pull-right-c {
    float: right;
    width: 38%;
    
}

.large {
    font-size: 200%
    
}

.medium {
    font-size: 75%
    
}

.small {
    font-size: 50%
    }

.action {
    background-color: #f2eecb;
  
}

&lt;/style&gt;

&lt;style type="text/css"&gt;
.red{ color: red;}
.remark-code, .remark-inline-code {
    font-family: 'Fira Mono', 'Source Code Pro', monospace;}
.remark-slide-scaler {
    overflow-y: auto;}
.remark-slide-content {
  font-size: 24px;
  padding: 20px 80px 20px 80px;
}
.remark-code, .remark-inline-code {
  background: #f0f0f0;
}
.remark-code {
  font-size: 20px;
}
.huge .remark-code { /*Change made here*/
  font-size: 200% !important;
}
.tiny .remark-code { /*Change made here*/
  font-size: 75% !important;
}

&lt;/style&gt;






# Data Wrangling 

.blockquote[the process of .out-t[cleaning and unifying messy and complex data sets for easy access and analysis]]

--

.pull-left[
- .yellow-h["data janitor work"]
- importing data
- cleaning data
- changing shape of data
]
.pull-right[
- fixing errors and poorly formatted data elements
- transforming columns and rows
- filtering, subsetting
]



---
background-image: url("images/dplyr.png")
background-position: 100% 100% 
background-size: 100% 100%

---

# Essential data wrangling tasks


1. Extract a subset of columns

--

2. Extract a subset of rows

--

3. Order the rows from smallest to largest (or largest to smallest)

--

4. Compute a table of summary statistics, perhaps by group

--

5. Create new columns

---

# The Five Verbs

The creater of `dplyr`, [Hadley Wickham](https://en.wikipedia.org/wiki/Hadley_Wickham), argues that most of the operations on a data table can be achieved with

- *select()*
- *filter()*
- *mutate()*
- *arrange()*
- *summarize()*

---

# Babynames Dataset

- Names of babies born in the U.S. .yellow-h[between 1880 and 2017]
- Source: Social Security Administration

--


```r
library(babynames)
glimpse(babynames)
Rows: 1,924,665
Columns: 5
$ year &lt;dbl&gt; 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880,…
$ sex  &lt;chr&gt; "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", …
$ name &lt;chr&gt; "Mary", "Anna", "Emma", "Elizabeth", "Minnie", "Margaret", "Ida",…
$ n    &lt;int&gt; 7065, 2604, 2003, 1939, 1746, 1578, 1472, 1414, 1320, 1288, 1258,…
$ prop &lt;dbl&gt; 0.07238359, 0.02667896, 0.02052149, 0.01986579, 0.01788843, 0.016…
```

---

# Find a subset of the columns using *select()*:

- `select()`: take a .yellow-h[subset of the columns (variables/features)]



```r
babynames %&gt;%
* select(year, name, n) %&gt;%
  head()
# A tibble: 6 × 3
   year name          n
  &lt;dbl&gt; &lt;chr&gt;     &lt;int&gt;
1  1880 Mary       7065
2  1880 Anna       2604
3  1880 Emma       2003
4  1880 Elizabeth  1939
5  1880 Minnie     1746
6  1880 Margaret   1578
```


---

# Using **%&gt;%**

- `%&gt;%` passes .yellow-h[result on left] into .yellow-h[first argument of function on right]

- `Chaining` functions together lets you read `Left-to-right`, `top-to-bottom`

---

# Using **%&gt;%**

You can build up a series of pipes


```r
*babynames %&gt;%                   # dataframe first and then...
  select(year, name, n) %&gt;%
  head()
```

---

# Using **%&gt;%**

You can build up a series of pipes



```r
babynames %&gt;%                   # dataframe first and then... 
* select(year, name, n) %&gt;%     # select columns `year`, `name`, and `n`
  head()                    
```

---

# Using **%&gt;%**

You can build up a series of pipes



```r
babynames %&gt;%                   # dataframe first and then... 
  select(year, name, n) %&gt;%     # select columns year, name, and n 
* head()                        # display header of the data frame
```


--


```
# A tibble: 6 × 3
   year name          n
  &lt;dbl&gt; &lt;chr&gt;     &lt;int&gt;
1  1880 Mary       7065
2  1880 Anna       2604
3  1880 Emma       2003
4  1880 Elizabeth  1939
5  1880 Minnie     1746
6  1880 Margaret   1578
```

---

# **select()** helpers


`:` select range of columns

```r
select(gapminder, income:population)
```

--

`-` select every column but

```r
select(gapminder, -c(income,population))
```

---

# **select()** helpers

`starts_with()` select columns that start with...

```r
select(gapminder, starts_with("p"))
```

--

`ends_with()` select columns that end with...

```r
select(gapminder, ends_with("y"))
```

--

`contains()` select columns whose names contain...

```r
select(gapminder, contains("e"))
```

---

class: action

#  Your Turn 1

- Please git clone the repository on [data wrangling activity](https://github.com/stat220/05-Data-Wrangling) from the course GitHub organization.

- Which of these is **NOT** a way to select the `name` and `n` columns together?


```r
select(babynames, -c(year, sex, prop))

select(babynames, name:n)

select(babynames, starts_with("n"))

select(babynames, ends_with("n"))
```

<div class="countdown" id="timer_61e5a8ba" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">02</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---


# Find a subset of the rows using *filter()*:

- `filter()`: take a .yellow-h[subset of the rows (observations)]


```r
babynames %&gt;%
  filter(name == "Bella") %&gt;%
  head()
# A tibble: 6 × 5
   year sex   name      n     prop
  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;    &lt;dbl&gt;
1  1880 F     Bella    13 0.000133
2  1881 F     Bella    24 0.000243
3  1882 F     Bella    16 0.000138
4  1883 F     Bella    17 0.000142
5  1884 F     Bella    31 0.000225
6  1885 F     Bella    25 0.000176
```


---

# Use both *filter()* and *select()*



```r
bella &lt;- babynames %&gt;%
  filter(name == "Bella") %&gt;%
  select(year, name, sex, n)
```

--

.pull-left[


```r
head(bella)
# A tibble: 6 × 4
   year name  sex       n
  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;
1  1880 Bella F        13
2  1881 Bella F        24
3  1882 Bella F        16
4  1883 Bella F        17
5  1884 Bella F        31
6  1885 Bella F        25
```

]

.tiny[
.pull-right[

```r
dim(bella)
[1] 144   4
class(bella)
[1] "tbl_df"     "tbl"        "data.frame"
```
]
]

---

# Some Operators

Operator|Definition                   
---|---
`&lt;`| less than                    
`&lt;=`|	less than or equal to
`&gt;`| greater than
`&gt;=`|	greater than or equal to 
`==`|	exactly equal to 
`!=`|	not equal to 
`x &amp; y`| `x` AND `y`                  
`x %in% y`| test if `x` is in `y`   


---
class:action

#  Your Turn 2

Use `filter()` with the logical operators to extract:

- All of the names where prop is greater than or equal to 0.08

- All of the babies named "Rose"

- All of the names that have a missing value for n


<div class="countdown" id="timer_61e5ab81" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">02</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---


# *summarize()* or *summarise()*

If we want to .yellow-h[compare summary statistics], we might use `summarize()`.


```r
babynames %&gt;% 
  filter(name == "Bella", sex == "F") %&gt;% 
* summarise(total = sum(n), max = max(n), mean = mean(n))
# A tibble: 1 × 3
  total   max  mean
  &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
1 57411  5121  416.
```

--

.pull-left[

```r
babynames %&gt;% 
  filter(name == "Bella", sex == "F") %&gt;% 
* summarize(n = n())
# A tibble: 1 × 1
      n
  &lt;int&gt;
1   138
```
]

.pull-right[

```r
babynames %&gt;% 
* summarize(nname = n_distinct(name))
# A tibble: 1 × 1
  nname
  &lt;int&gt;
1 97310
```
]

---

class: action

# Your Turn 3

Use the codes mentioned so far to compute three statistics:

1. the total number of children who ever had your name
1. the maximum number of children given your name in a single year
1. the mean number of children given your name per year 

<div class="countdown" id="timer_61e5ab8c" style="bottom:0;left:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">04</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---


# Boolean operators

For help, `?base::Logic`

&lt;img src="images/07-transform-logical.png" width="80%" style="display: block; margin: auto;" /&gt;

.footnote[Source: *R for Data Science*, by Grolemund &amp; Wickham]
---


class:action

# Your Turn 4

Use Boolean operators to alter the code below to return only the rows that contain:

- Girls named Rhea

- Names that were used by exactly 5 or 6 children in 1990

- Names that are one of Apple, Yoroi, Ada


```r
filter(babynames, name == "Ada" | name == "Rhea")
```

<div class="countdown" id="timer_61e5a954" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">04</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---


# Using *group_by()*


```r
babynames %&gt;% 
* group_by(year, sex)
# A tibble: 1,924,665 × 5
# Groups:   year, sex [276]
    year sex   name          n   prop
   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;  &lt;dbl&gt;
 1  1880 F     Mary       7065 0.0724
 2  1880 F     Anna       2604 0.0267
 3  1880 F     Emma       2003 0.0205
 4  1880 F     Elizabeth  1939 0.0199
 5  1880 F     Minnie     1746 0.0179
 6  1880 F     Margaret   1578 0.0162
 7  1880 F     Ida        1472 0.0151
 8  1880 F     Alice      1414 0.0145
 9  1880 F     Bertha     1320 0.0135
10  1880 F     Sarah      1288 0.0132
# … with 1,924,655 more rows
```

---


# Using *group_by()* along with *summarize()*


```r
babynames %&gt;%
* group_by(year) %&gt;%
* summarise(total = sum(n))
# A tibble: 138 × 2
    year  total
   &lt;dbl&gt;  &lt;int&gt;
 1  1880 201484
 2  1881 192696
 3  1882 221533
 4  1883 216946
 5  1884 243462
 6  1885 240854
 7  1886 255317
 8  1887 247394
 9  1888 299473
10  1889 288946
# … with 128 more rows
```

---


# *mutate()*

- `mutate()` lets us .yellow-h[create new variables based on manipulations of the old variables]



```r
babynames &lt;- babynames %&gt;%
  group_by(year) %&gt;%
* mutate(percent = prop * 100)
head(babynames)
# A tibble: 6 × 6
# Groups:   year [1]
   year sex   name          n   prop percent
  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;  &lt;dbl&gt;   &lt;dbl&gt;
1  1880 F     Mary       7065 0.0724    7.24
2  1880 F     Anna       2604 0.0267    2.67
3  1880 F     Emma       2003 0.0205    2.05
4  1880 F     Elizabeth  1939 0.0199    1.99
5  1880 F     Minnie     1746 0.0179    1.79
6  1880 F     Margaret   1578 0.0162    1.62
```

---

# *arrange()*

.yellow-h[Order rows from smallest to largest]


```r
arrange(.data, ...)
```

--


```r
arrange(babynames, n)
```

---

# *desc()*

Changes ordering from largest to smallest.

.scroll-box-10[

```r
*arrange(babynames, desc(n))
# A tibble: 1,924,665 × 6
# Groups:   year [138]
    year sex   name        n   prop percent
   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;int&gt;  &lt;dbl&gt;   &lt;dbl&gt;
 1  1947 F     Linda   99686 0.0548    5.48
 2  1948 F     Linda   96209 0.0552    5.52
 3  1947 M     James   94756 0.0510    5.10
 4  1957 M     Michael 92695 0.0424    4.24
 5  1947 M     Robert  91642 0.0493    4.93
 6  1949 F     Linda   91016 0.0518    5.18
 7  1956 M     Michael 90620 0.0423    4.23
 8  1958 M     Michael 90520 0.0420    4.20
 9  1948 M     James   88588 0.0497    4.97
10  1954 M     Michael 88514 0.0428    4.28
# … with 1,924,655 more rows
```
]
---

# Most common names in 1990


```r
babynames %&gt;%
* filter(year == 1990) %&gt;%
* arrange(desc(prop))
# A tibble: 24,719 × 6
# Groups:   year [1]
    year sex   name            n   prop percent
   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;  &lt;dbl&gt;   &lt;dbl&gt;
 1  1990 M     Michael     65282 0.0303    3.03
 2  1990 M     Christopher 52332 0.0243    2.43
 3  1990 F     Jessica     46475 0.0226    2.26
 4  1990 F     Ashley      45558 0.0222    2.22
 5  1990 M     Matthew     44800 0.0208    2.08
 6  1990 M     Joshua      43216 0.0201    2.01
 7  1990 F     Brittany    36538 0.0178    1.78
 8  1990 F     Amanda      34408 0.0168    1.68
 9  1990 M     Daniel      33815 0.0157    1.57
10  1990 M     David       33742 0.0157    1.57
# … with 24,709 more rows
```

---

# *top_n()* 

Most common name in each year


```r
babynames %&gt;%
* group_by(year) %&gt;%
* top_n(1, prop)
# A tibble: 138 × 6
# Groups:   year [138]
    year sex   name      n   prop percent
   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;  &lt;dbl&gt;   &lt;dbl&gt;
 1  1880 M     John   9655 0.0815    8.15
 2  1881 M     John   8769 0.0810    8.10
 3  1882 M     John   9557 0.0783    7.83
 4  1883 M     John   8894 0.0791    7.91
 5  1884 M     John   9388 0.0765    7.65
 6  1885 M     John   8756 0.0755    7.55
 7  1886 M     John   9026 0.0758    7.58
 8  1887 M     John   8110 0.0742    7.42
 9  1888 M     John   9247 0.0712    7.12
10  1889 M     John   8548 0.0718    7.18
# … with 128 more rows
```
---

class: action

# Your Turn 5

Find the year your first name is most common. 

&lt;img src="Day6_files/figure-html/unnamed-chunk-34-1.svg" style="display: block; margin: auto;" /&gt;


<div class="countdown" id="timer_61e5a950" style="bottom:0;left:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---

## Vectorized function

.font150[
a function that takes a vector as input, is applied to every element of the vector, and returns a vector (of the original length) as output
]

---

# *min_rank()*

.font120[
A go to ranking function (ties share the lowest rank)


```r
min_rank(c(50, 100, 1000))
[1] 1 2 3
```



```r
min_rank(desc(c(50, 100, 1000)))
[1] 3 2 1
```
]
---
class: action

#  Your Turn 6

- Use `min_rank()` and `mutate()` to rank each row in `babynames` from largest `prop` to smallest `prop`.

- Compute each name's rank within its `year` and `sex`.

- Then compute the median rank for each combination of `name` and `sex`, and arrange the results from highest median rank to lowest.


<div class="countdown" id="timer_61e5a9a9" style="bottom:0;left:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">06</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>


---

# Summary

.font120[
- Extract variables with `select()`

- Extract cases with `filter()` 

- Arrange cases, with `arrange()`

- Make tables of summaries with `summarize()`

- Make new variables, with `mutate()`
]

---

class: center, middle, inverse

## Acknowledgement: some of the slides are based on previous works of Adam Loy and Katie St. Clair.

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"highlightSpans": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
(function(time) {
  var d2 = function(number) {
    return ('0' + number).slice(-2); // left-pad 0 to minutes/seconds
  },

  time_format = function(total) {
    var secs = Math.abs(total) / 1000;
    var h = Math.floor(secs / 3600);
    var m = Math.floor(secs % 3600 / 60);
    var s = Math.round(secs % 60);
    var res = d2(m) + ':' + d2(s);
    if (h > 0) res = h + ':' + res;
    return res;  // [hh:]mm:ss
  },

  slide_number_div = function(i) {
    return document.getElementsByClassName('remark-slide-number').item(i);
  },

  current_page_number = function(i) {
    return slide_number_div(i).firstChild.textContent;  // text "i / N"
  };

  var timer = document.createElement('span'); timer.id = 'slide-time-left';
  var time_left = time, k = slideshow.getCurrentSlideIndex(),
      last_page_number = current_page_number(k);

  setInterval(function() {
    time_left = time_left - 1000;
    timer.innerHTML = ' ' + time_format(time_left);
    if (time_left < 0) timer.style.color = 'red';
  }, 1000);

  slide_number_div(k).appendChild(timer);

  slideshow.on('showSlide', function(slide) {
    var i = slide.getSlideIndex(), n = current_page_number(i);
    // reset timer when a new slide is shown and the page number is changed
    if (last_page_number !== n) {
      time_left = time; last_page_number = n;
      timer.innerHTML = ' ' + time_format(time); timer.style.color = null;
    }
    slide_number_div(i).appendChild(timer);
  });
})(60000);
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
