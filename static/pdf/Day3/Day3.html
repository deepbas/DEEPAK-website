<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Objects and Basics Data Visualization</title>
    <meta charset="utf-8" />
    <meta name="author" content="Bastola" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/countdown-0.3.5/countdown.css" rel="stylesheet" />
    <script src="libs/countdown-0.3.5/countdown.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, top, my-title, title-slide

# Data Objects and Basics Data Visualization
## <br/> STAT 220
### Bastola
### January 10 2022

---


&lt;style type="text/css"&gt;

.hljs-github .hljs {
    background: #e5e5e5;
}

.inline-c, remark-inline-code {
   background: #e5e5e5;
   border-radius: 3px;
   padding: 4px;
   font-family: 'Source Code Pro', 'Lucida Console', Monaco, monospace;
}

.yellow-h{
   background: #ffff88;
}

.out-t, remark-inline-code {
   background: #9fff9f;
   border-radius: 3px;
   padding: 4px;
   
}

.pull-left-c {
    float: left;
    width: 58%;
    
}

.pull-right-c {
    float: right;
    width: 38%;
    
}

.medium {
    font-size: 75%
    
}

.small {
    font-size: 50%
    }

.action {
    background-color: #f2eecb;
  
}

&lt;/style&gt;




&lt;style type="text/css"&gt;
.red{ color: red;}
&lt;/style&gt;


# Objects in R

- Anything created or imported into R is called an .yellow-h[object]
&lt;br&gt;
--
  - vectors, data frames, matrices, lists, functions, lm, ...

--

- We usually store objects in the workspace using the assignment **operator** `&lt;-`



```r
x &lt;- c(8,2,1,3)
ls()
## [1] "x"
```

--

- The `=` operator also does assignment, but it is mainly used for argument specification inside a function.

--


```r
y &lt;- rnorm(3, mean = 10, sd = 2)
ls()
## [1] "x" "y"
```

--

- .red[Please don't use `=` for assignment!!!]


---

# Data structures and types

.pull-left[

- Every object is a **vector** 

- `NULL` = empty object (vector of length 0)

- `typeof()`: tells us about storage of data
    - Logical: TRUE or FALSE 
    - Integer and double
    - Character: string ("") of text
    - List

]    

--

.pull-right[


```r
x &lt;- c(8,2,1,3)
typeof(x)  # type of storage mode 
## [1] "double"
typeof(c(8L,2L,1L,3L))  # adding L forces integer type
## [1] "integer"
x == 1
## [1] FALSE FALSE  TRUE FALSE
typeof(x == 1)
## [1] "logical"
```

]


---

# Data structures and types

.pull-left[

- Every object is a **vector** 

- `NULL` = empty object (vector of length 0)

- `typeof()`: tells us about storage of data
    - Logical: TRUE or FALSE 
    - Integer and double
    - Character: string ("") of text
    - List

`class` further describes the object


]    


.pull-right[


```r
x &lt;- c(8,2,1,3)
typeof(x)  # type of storage mode 
## [1] "double"
typeof(c(8L,2L,1L,3L))  # adding L forces integer type
## [1] "integer"
x == 1
## [1] FALSE FALSE  TRUE FALSE
typeof(x == 1)
## [1] "logical"
```

&lt;br&gt;


```r
class(x)   # object class is numeric
## [1] "numeric"
```

]

---

# Object Oriented Programming

- In R, commands care about object class and type

--

  - Ex: the default `plot` command wants a vector of data or a formula to form a scatterplot
  
--


```r
plot(y ~ x, data= mydata) # makes scatterplot if x and y numeric
```

--

- but if you give `plot` a `lm` regression object it will produce a set of diagnostic plots for that regression model.


```r
my_lm &lt;- lm(y ~ x, data= mydata)  # make a linear model
plot(my_lm)  # makes multiple diagnostic plots
```

--

- In your **Console** window, type `?plot` then hit **tab**. 

&gt; ?plot

    - see `plot`, `plot.acf`, ...

---

# Atomic Vectors and lists

- R uses two types of vectors to store info
    - **atomic vectors**: all entries have the same data type 
    - **lists**: entries can contain other objects that can differ in data type
    
- All vectors have a length

--


```r
x    # atomic vector
## [1] 8 2 1 3

length(x)
## [1] 4
```

--


```r

x_list &lt;- list(x, 1, "a")  # list

length(x_list)
## [1] 3
```

---

# Atomic Vectors: Matrices

- You can add **attributes**, such as **dimension**, to vectors
- A **matrix** is a 2-dimensional vector containing entries of the same type

--

.pull-left[


```r
x_mat &lt;- matrix(x, nrow = 2, byrow = TRUE)
x_mat
##      [,1] [,2]
## [1,]    8    2
## [2,]    1    3
attributes(x_mat)
## $dim
## [1] 2 2
```



```r
typeof(x_mat)   # type of entries
## [1] "double"
class(x_mat)   # info about object
## [1] "matrix" "array"
```

]

--
.pull-right[

- or you can bind vectors of the same length to create columns or rows:

```r
x_mat2 &lt;- cbind(x, 2*x)
x_mat2
##      x   
## [1,] 8 16
## [2,] 2  4
## [3,] 1  2
## [4,] 3  6
```


]


---

# Lists: Data frames 

- A **data frame** is a list of atomic vectors of the same length, but not necessarily the same data type
- the `babynames` data frame has columns that are `integer` and `character` types

--


```r
babynames &lt;- `read.csv`("https://raw.githubusercontent.com/deepbas/statdatasets/main/baby-names-by-state.csv")
class(babynames)
## [1] "data.frame"
typeof(babynames)
## [1] "list"
glimpse(babynames)
## Rows: 502,618
## Columns: 5
## $ state  &lt;chr&gt; "AK", "AK", "AK", "AK", "AK", "AK", "AK", "AK", "AK", "AK", "AK…
## $ year   &lt;int&gt; 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 196…
## $ name   &lt;chr&gt; "David", "Michael", "Robert", "John", "James", "Mark", "Richard…
## $ number &lt;int&gt; 151, 139, 135, 126, 123, 91, 86, 74, 73, 66, 57, 50, 49, 43, 43…
## $ sex    &lt;chr&gt; "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", …
```

---

# Coercion and the factor class

- Entries in atomic vectors must be the same data type
- R will default to the most complex data type if more than one type is given

--


```r
y &lt;- c(1, 2, "a")
```

--


```r
typeof(y)
## [1] "character"
y
## [1] "1" "2" "a"
```

--

- This example was **implicit coercion**

--

- **Explicit coercion** intentionally forces a data type that is different from the "default" type

```r
y &lt;- as.character(c(1,2,3))
```


```r
typeof(y)
## [1] "character"
y
## [1] "1" "2" "3"
```

---

#  Coercion and the factor class

- Logical values coerced into 0 for `FALSE` and 1 for `TRUE` when applying math functions


```r
x &lt;- c(8,2,1,3)
x &gt;= 5  # which entries &gt;= 5?
## [1]  TRUE FALSE FALSE FALSE
sum(x &gt;= 5)  # how many &gt;=5 ?
## [1] 1
```

- What will `mean` of a logical vector measure?


```r
mean(x &gt;= 5) 
```

--



```
## [1] 0.25
```

---

# Data types: factors 

- Factors are a class of data that are stored as **integers**


```r
x_fct &lt;- as.factor(c("yes", "no", "no"))

class(x_fct)
## [1] "factor"
typeof(x_fct)
## [1] "integer"
```

--

- The attribute `levels` is a character vector of possible values
    - Values are stored as the integers (1=first `level`, 2=second `level`, etc)
    - Levels are ordered alphabetically/numerically (unless specified otherwise)
    
--


```r
str(x_fct)
##  Factor w/ 2 levels "no","yes": 2 1 1
levels(x_fct)
## [1] "no"  "yes"
```
---

# Subsetting: Atomic Vector

- subset with `[]` by referencing index value (from 1 to vector length):


```r
x
## [1] 8 2 1 3
x[c(4, 2)]  # get 4th and 2nd entries
## [1] 3 2
```

--

- subset by omitting entries

```r
x[-c(4, 2)]  # omit 4th and 2nd entries
## [1] 8 1
```

--

- subset with a logical vector

```r
x[c(TRUE, FALSE, TRUE, FALSE)]  # get 1st and 3rd entries
## [1] 8 1
```


---

# Subsetting: Matrices

- access entries using subsetting `[row,column]`

```r
x_mat2
##      x   
## [1,] 8 16
## [2,] 2  4
## [3,] 1  2
## [4,] 3  6
```

--


```r
x_mat2[, 1] # first column
## [1] 8 2 1 3
```

--


```r
x_mat2[1:2, 1] # first 2 rows of first column
## [1] 8 2
```

--

- .yellow-h[R doesn't always preserve class]:  


```r
class(x_mat2[1,])  # one row (or col) is no longer a matrix (1D)
## [1] "numeric"
```

---

# Subsetting: Data frames

- you can access entries like a matrix:


```r
x_df &lt;- data.frame(x = x, double_x = x*2)
x_df
##   x double_x
## 1 8       16
## 2 2        4
## 3 1        2
## 4 3        6
```

--


```r
x_df[, 1]  # first column, all rows
## [1] 8 2 1 3
```

--


```r
class(x_df[, 1])  # first column is no longer a data frame
## [1] "numeric"
```

--

- One column of a data frame is no longer a data frame 

---

# Subsetting: Data frames 

.pull-left[
- or access columns with `$`

```r
x_df$x  # get variable x column
## [1] 8 2 1 3
```



- you can also use column names to subset:

```r
# get 2 rows of Name and Sex
#babynames[1:2, c("name", "sex")] 
```

]

--

.pull-right[

- Recall: a **list** is a vector with entries that can be different object types

```r
my_list &lt;- list(myVec = x, 
                myDf = x_df, 
                myString = c("hi", "bye"))
my_list
## $myVec
## [1] 8 2 1 3
## 
## $myDf
##   x double_x
## 1 8       16
## 2 2        4
## 3 1        2
## 4 3        6
## 
## $myString
## [1] "hi"  "bye"
```


]

---

# Subsetting: Lists 

.pull-left[

- Like a data frame, can use the `$` to access **named** objects stored in the list
  - E.g.: `my_list$myDf` return the **data frame** `myDf` 


```r
my_list$myDf
##   x double_x
## 1 8       16
## 2 2        4
## 3 1        2
## 4 3        6
class(my_list$myDf)
## [1] "data.frame"
```

]

--

.pull-right[

- one `[]` operator gives you the object at the given location but preserves the list type
  - `my_list[2]` return a **list** of length one with entry `myDf` 
  

```r
my_list[2]
## $myDf
##   x double_x
## 1 8       16
## 2 2        4
## 3 1        2
## 4 3        6
```



```r
str(my_list[2])
## List of 1
##  $ myDf:'data.frame':	4 obs. of  2 variables:
##   ..$ x       : num [1:4] 8 2 1 3
##   ..$ double_x: num [1:4] 16 4 2 6
```

]

---

# Subsetting: Lists 

- the double  `[[]]` operator  gives you the object stored at that location (equivalent to using `$`)
  - `my_list[[2]]` or `my_list[["myDf"]]` return the **data frame** `myDf` 


```r
my_list[[2]]
##   x double_x
## 1 8       16
## 2 2        4
## 3 1        2
## 4 3        6
str(my_list[[2]])
## 'data.frame':	4 obs. of  2 variables:
##  $ x       : num  8 2 1 3
##  $ double_x: num  16 4 2 6
```

---
class: action

# Your Turn
Please git clone the repository [02-Data-Objects-Viz](https://github.com/stat220/02-DataObj_Viz_Activity) to your local folder.

````md
```{r}
babynames &lt;- read.csv("https://raw.githubusercontent.com/deepbas/statdatasets/main/baby-names-by-state.csv")
x &lt;- c(3,6,9,5,1)
x.mat &lt;- cbind(x, 2*x)
x.df &lt;- data.frame(x=x,double.x=x*2)
my.list &lt;- list(myVec=x, myDf=x.df, myString=c("hi","bye"))

```
````

### Question 1: data types

- What data type is `x`? What data type is `babynames$number`? 
- What data type is `c(x, babynames$year)`?
- What data type is `c(x,NA)`?  What data type is `c(x,"NA")`?


<div class="countdown" id="timer_61dc68f1" style="top:1;right:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>



---

class: action

# Your Turn

### Question 2: Subsetting and coercion

- How can we reverse the order of entries in `x`?
- What does `which(x &lt; 5)` equal?
- What does `sum(c(TRUE,FALSE,FALSE,FALSE, TRUE))` equal?
- What does `sum(x[c(TRUE,FALSE,FALSE,FALSE, TRUE)])` equal?
- What does `sum(x &lt; 5)` equal?
- What does `sum(x[x &lt; 5])` equal?
- Why `dim(x.mat[1:2,1])` return `NULL` while `dim(x.mat[1:2,1:2])` returns a dimension?


<div class="countdown" id="timer_61dc6590" style="top:1;right:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---
class: action

# Your Turn

### Question 3: Lists

- Using `my.list`, show three ways to write one command that gives the 3rd entry of variable `x` in data frame `myDf`
- What class of object does the command `my.list[3]` return?
- What class of object does the command `my.list[[3]]` return?
- What class of object does the command `unlist(my.list)` return? Why are all the entries `character`s?

<div class="countdown" id="timer_61dc66bb" style="top:1;right:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

--

### Question 4: Data Frames

- What is the total number of babies born in Minnesota with name `Alex`?
- In what year were highest number of babies were named `Alex` in Minnesota?


<div class="countdown" id="timer_61dc6584" style="top:1;right:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---

class: center, inverse, bottom
background-image: url("images/data_viz.jpg")
background-size: contain


# .red[Data Visualization]


### provides a powerful way to communicate data-driven findings, motivate analyses, and detect flaw

---

# **ggplot2**  &amp;mdash; Overview

- A powerful package for visualising data 

--

- Used widely by academics and industries alike

--

- Some useful resources

    - [The package documentation](https://www.rdocumentation.org/packages/ggplot2/versions/3.2.1)
    - [The book](https://ggplot2-book.org/) by its creator Hadley Wickham
    - [The reference page](https://ggplot2.tidyverse.org/reference/)
    - [The extensions](https://exts.ggplot2.tidyverse.org/), maintained by the `ggplot2` community

---
# **ggplot2** &amp;mdash; Basics 

- The `ggplot` function and the `data` argument
  - specify a data frame in the main `ggplot` function


```r
ggplot(data = df)
```

--

- The mapping aesthetics, or .yellow-h[aes]; most importantly, the variable(s) that we want to plot
  - specify as an additional argument in the same `ggplot` function


```r
ggplot(data = df, mapping = aes(x = x-variable, y = y-variable))
```

---

# **ggplot2** &amp;mdash; Basics

- The geometric objects, or .yellow-h[geom]; the visual representations
  - specify, after a plus sign .yellow-h[+], as an additional function


```r
ggplot(data = df, mapping = aes(x = x-variable, y = y-variable)) +
*      geom_point()
```

- Additional aesthestics like `color`, `size`, `shape`, and `alpha` (i.e. transparency) are possible.
  

```r
ggplot(data = df, mapping = aes(x = x-variable, y = y-variable)) +
*      geom_point(color = z-variable)
```

---

class: action

# Your Turn


```r
#install.packages("tidyverse")
library(tidyverse)
babynames_MN_John &lt;- babynames %&gt;% filter(state=="MN",  name == "John")
```


### Question 5: Basic Plot using `ggplot2`.

- What are the grammar of graphics needed to create a scatter-plot of the number of babies born in Minnesota named `John` vs year they were born?
- Fill in the data and aesthetic mapping in the below code chunk. What is returned? What's missing?
- Add the appropriate geometric object to create the scatter plot. This is called adding a *layer* to a plot.
- Repeat the above steps with babies named `John` from Minnesota or Michigan.


<div class="countdown" id="timer_61dc6734" style="top:1;right:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---

# Your Turn &amp;mdash; add appropriate labels

````md
```{r}
ggplot(data = babynames_MN_MI_John , mapping = aes(x = year, y = number)) +
  geom_point(aes(colour=state))+
  xlab("Year") +
  ylab(bquote(Number~of~babies~named~.("John"))   
```
````

![](Day3_files/figure-html/unnamed-chunk-46-1.svg)&lt;!-- --&gt;



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"highlightSpans": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
