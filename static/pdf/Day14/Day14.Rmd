---
title: "Iterations"
subtitle: "<br/> STAT 220"
author: "Bastola"
date: "`r format(Sys.Date(), ' %B %d %Y')`"
output:
  xaringan::moon_reader:
    css: ["default", css/xaringan-themer-solns.css, css/my-theme.css, css/my-font.css]
    lib_dir: libs
    chakra: libs/remark-latest.min.js
    seal: false
    nature:
      highlightStyle: googlecode #http://arm.rbind.io/slides/xaringan.html#77
      highlightLines: true
      highlightLanguage: r
      countIncrementalSlides: true
      slideNumberFormat: "%current%"
      titleSlideClass: ["left", "middle", "inverse"]
      ratio: "16:9"
      countdown: 60000
    includes:
      in_header: header.html  
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
options(htmltools.preserve.raw = FALSE)


knitr::opts_chunk$set(echo = TRUE, 
                      dev = 'svg',
                      collapse = TRUE, 
                      comment = NA,  # PRINTS IN FRONT OF OUTPUT, default is '##' which comments out output
                      prompt = FALSE, # IF TRUE adds a > before each code input
                      warning = FALSE, 
                      message = FALSE,
                      fig.height = 3, 
                      fig.width = 4,
                      out.width = "100%"
                      )


# load necessary packages
library(tidyr)
library(dplyr)
library(ggplot2)
library(countdown)
library(ggthemes)
library(tidyverse)
library(stringr)
library(xaringanExtra)
xaringanExtra::use_panelset()
xaringanExtra::use_tachyons()
library(flipbookr)
library(htmlwidgets)
library(lubridate)
library(palmerpenguins)

library(knitr)
library(kableExtra)
library(fontawesome)
#library(rvest)
library(forcats)
library(patchwork)
library(readr)
library(stringr)
library(icons)
library(tidytext)

yt <- 0

energy <- readr::read_csv("https://raw.githubusercontent.com/deepbas/statdatasets/main/energy.csv",
                    col_type = cols(
                     .default = col_double(), 
                      Timestamp = col_datetime(format = ""),
                      dayWeek = col_factor(levels=c("Mon","Tues","Wed","Thurs","Fri","Sat","Sun"))
                     ))

```


```{r xaringan-themer, include = FALSE}
# Use xaringan theme from first set
```


layout: true
  
<!-- <div class="my-footer"><span>Bastola</span></div> -->
<!-- this adds the link footer to all slides, depends on my-footer class in css-->

---
class: title-slide, middle
<!-- background-image: url("assets/title-image2.jpg") -->
background-position: 10% 90%, 100% 50%
background-size: 160px, 100% 100%

# .fancy[Iterations and Functionals]

### .fancy[Stat 220]

.large[Bastola]

`r format(Sys.Date(), ' %B %d %Y')`

---

# Why repeat ourselves?

.pull-left[
```{r}
tinydata <- tribble(
  ~case, ~x, ~y, ~z, 
  "a", 5, 3, -2,
  "b", 7, 1, -5,
  "c", 9, 12, -3
)
```

```{r}
tinydata
```
]

--

.pull-right[

.fancy[.bold[Find the mean of each columns]]

```{r}
mean(tinydata$x)
```

```{r}
mean(tinydata$y)
```

```{r}
mean(tinydata$z)
```

]


---

# Iteration

.font120[
> Iteration is the process of repeating the same action over and over again
]

.fot120[

.fancy[Multiple ways to do in R]

- .bold[loops] using `for`, `while`, etc

- .bold[vectorized] functions that apply the same function to every element of a vector

- .bold[functional] functions that apply the same function to elements in a vector, matrix, data frame, or list
]

---



# for loops

.font120[
> A way to iterate through a series of items stored as data object in R.
]

--

```{r}
items <- c("grapes","bananas","chocolate","bread")
for(i in items){
  print(i)
}

```


--

.pull-left[
```{r}
i <- items[1]
print(i)
```
]

.pull-right[

```{r}
i <- items[2]
print(i)
```
]

---

# for loop components

.font120[
<blockquote>
the for() function which we use to specify

  - what object we're drawing from and
   
  - what object we are writing to.

]


```
for( i  in  items  )
     ^        ^
     |        |___ object we are drawing from
     |
obj. we write each item to

```
---

# for loop components

.font120[
<blockquote>
The brackets {}

  - Inside the brackets we house the code that is going to happen each iteration.
]


```
 for( i  in  items  ){
    |~~~~~~~~~~~~~~~~|   
    |~~~~~~~~~~~~~~~~|
    |~~~~~~~~~~~~~~~~| code we need perform on each iteration.
    |~~~~~~~~~~~~~~~~|
    |~~~~~~~~~~~~~~~~|
    }

```


---


# for() loops and storing output

```{r}
letters
```

--

```{r}
basket <- rep(NA,10) # numeric vector of length 3
basket
```

--

```{r}
# Each loop, we store the output of some code.
for(i in 1:10){
  basket[i] <- str_glue(letters[i],letters[i+1])
}
basket
```


---

# For loops `tinydata`

- Let’s iterate calculation of column means:

```{r}
my_means <- rep(NA, 3) 
my_means
```

--

```{r}
for (i in 1:3) {  # three columns to get the mean for
  my_means[i] <- mean(tinydata[[i+1]])  # mean of col. i+1 (skip col. 1)
}
my_means
```


---

# For loops: preallocation output space
.font120[
- About 12 seconds without preallocation and less than a second with (elapsed time).
]

.pull-left[
.brown[Without preallocation]
```{r}
system.time({
  output <- NULL
  for (i in 1:100000) {
    output <- c(output, i)
  }
})
```

]
.pull-right[
.brown[With preallocation]
```{r}
system.time({
  output <- rep(NA, 100000)
  for (i in 1:100000) {
    output[i] <- i
  }
})
```
]


---

# For loops: index vector

- seq_along(df) index based on columns of data frame

```{r}
seq_along(tinydata)
```

- Another common way of indexing

```{r}
1:nrow(tinydata)
```

- Along the columns

```{r}
1:ncol(tinydata)
```

---

# For loop with ifelse


```{r}
my_means <- rep(NA, ncol(tinydata))  

for (i in seq_along(tinydata)){  # iterate over all columns
  my_means[i] <- ifelse(is.numeric(tinydata[[i]]), mean(tinydata[[i]]), NA)
}
```

```{r}
my_means
```


---

# Function for conditional evaluation

- if x is numeric then standardize, else just return x

```{r}
standardize <- function(x, ...){   # ... used for arbitrary number of arguments
  if (is.numeric(x)){              # condition
    (x - mean(x, ...))/sd(x, ...)  # if TRUE, standardize
  } else{                          # else (FALSE)
    x                              # return x unchanged
  }
}
```

--

```{r}
standardize(c(1,2,3,4))
```

--

```{r}
standardize(c("a", "b", "2", NA), na.rm = TRUE)
```

---

# Standardizing tinydata

- Allocate storage in a new data frame:

```{r}
scaled_tinydata <- tinydata %>%
  mutate(
    x = NA, 
    y = NA, 
    z = NA
  )
```

--

```{r}
scaled_tinydata
```

---

# Standardizing tinydata

- For loop for iteration:

```{r}
for (i in seq_along(tinydata)){ 
    scaled_tinydata[, i] <- standardize(tinydata[[i]])
}
```

--

```{r}
scaled_tinydata
```

---

class: middle

# Vectorization 

.font120[

- A vectorized function will apply the same operation (function) to each element of a vector.

  * avoid loops by applying operations to each element of a vector
]
---

# Vectorization


```{r}
x <- c(10,20,30,40)
log10(x)   # log10 is a vectorized function
```

--

- The for loop version

```{r}
out <- rep(NA, 4)
for (i in 1:4)
  { out[i] <- log10(x[i]) }
out
```


---
name: yourturn
template: section
class: action

# <i class="fa fa-pencil-square-o" style="font-size:48px;color:purple">&nbsp;Your&nbsp;Turn&nbsp;`r (yt <- yt + 1)`</i>    

.font120[
Please git clone the github repository on [simple iterations](https://github.com/stat220/13-simple-iterations). Write a `for` loop that calculates the mean of the numeric variables in the
`penguins` data set and stores the means in a named vector.]

```{r, echo=FALSE}
glimpse(penguins)
```

```{r echo=FALSE}
countdown(4)
```


---
class: middle

# Functionals

.font120[
- A .bold[functional] function will apply the same operation (function) to each element of a vector, matrix, data frame or list.]

.pull-left[
  - base-R: `apply` family of commands
  
  -`purrr` package: `map` family of commands
]
.pull-right[
<img src="images/purrr.png" width=300>
]

---

# `apply` family of commands

- R has a family of commands that apply a function to different parts of a vector, matrix or data frame.

<blockquote>
<p style="background-color: #404040"> .bold[lapply(X, FUN)]:</p> applies the `FUN` to each element in the vector/list `X`. Returns a list with length equal to that of the vector
</blockquote>

<br>

<blockquote>
<p style="background-color: #404040"> .bold[sapply]:</p> works like `lapply` but returns a vector (so `FUN` can only return one value)
</blockquote>
<br>

---

# `apply` family of commands

- R has a family of commands that apply a function to different parts of a vector, matrix or data frame.

<blockquote>
<p style="background-color: #404040"> .bold[apply(matrix, MARGIN, FUN)]:</p> applies the function `FUN` to the matrix. `MARGIN` given (1=row, 2=column, c(1,2)=rows and cols). Returns an atomic .bold[vector] or .bold[matrix]
</blockquote>

<br>

<blockquote>
<p style="background-color: #404040"> .bold[tapply(x,y,FUN))]:</p>  applies `FUN` to atomic vector (variable) `x` for each group in categorical variable `y`. Returns an atomic .bold[vector] with a `dimnames` attribute
</blockquote>

---

# `purr` package

<blockquote>
powerful package for iteration with the same functionality as apply commands, but more readable (according to Hadley)

</blockquote>
<br>
<img src="images/map.png" width=700 class="center">


- map(.x, .f) maps the function .f to elements in the vector/list .x

---
class: middle

# `lapply` tiny example

.pull-left[
```{r}
lapply(tinydata, FUN = mean)
```

- a 3x4 data frame is .bold[summarized] in a list of length 4.
]

--

.pull-right[
.font120[
- R sees tinydata as a list whose elements are column vectors (variables)

- the FUN is applied to each list element 

- a list is returned

- length is the number of variables in the data frame
]
]

---

# `map`

> In `purrr`, the `map` function is equivalent to `lapply`

```{r}
library(purrr)
map(tinydata, .f = mean)
```


---

# `sapply` tiny example

> Output is an atomic vector (`s`implify)

```{r}
sapply(tinydata, FUN = mean)
```

- a 3x4 data frame is .bold[summarized] in a vector of length 4.


---

# `map_dbl`

> `map_dbl` is equivalent to `sapply`

.code120[
```{r}
map_dbl(tinydata, .f = mean)
```
]

---

# `map_df`

> `map_df` returns a data frame instead of a vector

```{r}
map_df(tinydata, .f = mean)
```

- No equivalency in base-R `apply`!


---

# Iterate or dplyr?!

- `summarize_all`, `summarize_if`, `summarize_at` are all options that apply  `.funs` to .bold[columns] of a data frame

- `if` option needs a logical function that determines which .bold[columns] to apply the `.funs` to 


```{r}
tinydata %>%
  summarize_if(is.numeric, .funs = mean) #<<
```

---

# functionals: single function that mutates

> `standardize` function gives us a list of standardized values

```{r}
lapply(tinydata, FUN = standardize)
```

- a 3x4 data frame is .bold[mutated] to a list of 4 vectors of length 3 each

---

# `lapply` tiny example

> Using `dplyr::bind_cols` converts the list to a data frame with variables equal to list entries

```{r}
lapply(tinydata, FUN = standardize) %>%
  bind_cols()  #<<
```


---

# map_df

> In `purrr`, the `map_df` is equal to `lapply` + `bind_cols`:


```{r}
map_df(tinydata, .f = standardize)
```


- a 3x4 data frame is mutated to .bold[standardized] 3x4 data frame


---

# Iterate or dplyr?!

- `mutate_all`, `mutate_if`, `mutate_at` are all options that apply `.funs` to columns of a data frame

- if option needs a logical function that determines which columns to apply the `.funs` to

```{r}
tinydata %>%
  mutate_if(is.numeric, .funs = standardize) #<<
```

---

# applying multiple functions

- Let’s get the 0.1 and 0.9 quantile for variables in `tinydata`

```{r}
quantile(tinydata$x, probs = c(.1, .9))
```

```{r}
quantile(tinydata$y, probs = c(.1, .9))

```

```{r}
quantile(tinydata$z, probs = c(.1, .9))

```

--

-  the function output is a vector of length 2 (same lengths as probs)

---

# `map_df`: getting quantiles


```{r}
tinydata %>% 
  select_if(is.numeric) %>%   # only numeric columns
  map_df(
    .f = quantile,   # function to apply to cols
    probs = c(.1, .9)) # extra function arguments
```

---

# map_df: getting quantiles

> Can use `.id` to record the variable names from tinydata:

```{r}
tinydata %>% 
  select_if(is.numeric) %>% 
  map_df(
    .f = quantile, 
    probs = c(.1, .9), 
    .id = "variable")
```

---

class: middle

# `map_df` options


.font120[
.fancy[There are two types of `map_df`]


  - `map_dfr`: which row binds the list created by map
    - entries in the list are rows in the data frame
      
  - `map_dfc`: which column binds the list created by map
    - entries in the list are columns in the data frame
]    


---

# Iterate or dplyr?!

.font120[
- `summarize_all`, `summarize_if`, `summarize_at` can work with functions like `quantile` that return multiple values.

- the .bold[form] of the output is a transposed version of `map_df`
]

--

```{r}
tinydata %>% 
    summarize_if(is.numeric, .funs = quantile, probs = c(.1, .9)) #<<
```

- .bold[rows] = 0.1 and 0.9 quantiles
- .bold[cols] = variables


---


# Iterate or dplyr?!

.font120[
- We need to manually add a percentile variable to help us ID the value in each row
]


.code120[
```{r}
tinydata %>% 
    summarize_if(is.numeric, .funs = quantile, probs = c(.1, .9)) %>%
    mutate(percentile = c(10,90)) #<<
```
]

---

# Example: Energy Data

- Recall the wide version of the energy data:

```{r}
energy %>% select(dayWeek, `Center_for_Mathematics_&_Computing`) %>% glimpse
```

---

# Quantiles from wide data

- Let’s get 0.1 and 0.9 quantiles for 3 buildings:

```{r}
energy_quant <- energy %>% 
  select("Sayles-Hill" ,"Language_&_Dining_Center", "Olin_Hall_of_Science") %>% 
  map_df(
    .f = quantile, 
    probs = c(.1, .9), 
    na.rm = TRUE, 
    .id = "building") 
```

--

```{r, echo=FALSE}
energy_quant
```


---

# Quantiles from wide data

- Let’s put quantiles in one column:

```{r}
energy_quant <- energy_quant  %>% 
  pivot_longer(
    names_to = "percentile", 
    values_to = "value",
    cols = 2:3)
```

--

```{r, echo=FALSE}
energy_quant
```


---

`r chunk_reveal("demo1", widths = c(40, 40), font_size_code="100%", title = "## Plot of Quantiles")`

```{r,demo1, eval=FALSE, echo=FALSE }
energy_quant   %>%
  mutate(percentile = parse_number(percentile)) %>%
  ggplot(aes(y = percentile, x = value, color=building)) +
  geom_point() + 
  geom_line(aes(group=building)) + 
  labs(y="Percentile (%)",x="KWH") +
  scale_y_continuous(breaks=seq(10,90,by=10)) +
  theme(legend.position="bottom", 
        legend.text = element_text(size=5), 
        legend.title=element_text(size=8))

```

---

# Quantiles from wide data

- create a vector of quantile probs:

```{r}
p <- seq(0.05,0.95, by = .05)  # every 5th quantile
energy_quant <- energy %>% 
  select("Sayles-Hill" ,"Language_&_Dining_Center", "Olin_Hall_of_Science") %>% 
  map_df(
    .f = quantile, 
    probs = p, 
    na.rm = TRUE, 
    .id = "building") %>% 
  pivot_longer(
    names_to = "percentile", 
    values_to = "value",
    cols = 1 + 1:length(p), # quantiles start in col 2
  )
```


---

# Quantiles from wide data
.scroll-box-20[
```{r}
energy_quant
```
]

---
class: center

# Quantiles from wide data


```{r, echo = FALSE, out.width='50%', fig.height=4, fig.width=4}
energy_quant %>%
  mutate(percentile = parse_number(percentile)) %>%
  ggplot(aes(y = percentile, x = value, color=building)) +
  geom_point() + 
  geom_line(aes(group=building)) + 
  labs(y="Percentile (%)",x="KWH") +
  scale_y_continuous(breaks=seq(10,90,by=10)) +
  theme(legend.position="bottom", legend.text = element_text(size=5), legend.title=element_text(size=8))

```

---

#  Quantiles from long data

- What if we have the long version of this data?

```{r}
energy_long <- energy %>% 
  pivot_longer(
    names_to = "building", 
    values_to = "energyKWH",
    cols = 9:90) %>%
  filter(building %in% c("Sayles-Hill" ,
                         "Language_&_Dining_Center", 
                         "Olin_Hall_of_Science") )
```

---
class: middle

# Quantiles from long data

.font130[
.bold[Goal:] get quantiles for every `building` and `dayWeek`
]
.font120[
- We don’t have many columns of measurements to apply a function to

- We have groups (building and month) that we need to summarize with quantile (more than one output value)
]
---

# Quantiles from long data

- Let’s get quantiles for every building and day of the week:

```{r}
energy_long_quant <- energy_long %>% 
  group_by(building, dayWeek) %>%
  summarize(value = quantile(energyKWH, probs = c(.1, .9), na.rm = TRUE)) 
```

--

.scroll-box-10[
```{r, echo=FALSE}
energy_long_quant
```
]

---

# Quantiles from long data

- Need to add a percentile 

```{r}
energy_long_quant <- energy_long_quant %>%
  mutate(percentile = c(10,90)) #<<
```

--

.scroll-box-10[
```{r}
energy_long_quant
```
]

---

# Quantiles from long data

For all quantiles in .out-t[p <- seq(0.05,0.95, by = 0.05))]

```{r}
energy_long_quant <- energy_long %>% 
  group_by(building, dayWeek) %>%
  summarize(value = quantile(energyKWH, probs = p, na.rm = TRUE))  %>%
  mutate(percentile = 100*p)
```
.scroll-box-10[
```{r, echo=FALSE}
energy_long_quant
```
]


---
class: middle

# Quantiles from long data

.code120[
```{r, eval=FALSE}
energy_long_quant %>%
  ggplot(aes(y = percentile, x = value, color=building)) +
  geom_point() + 
  geom_line(aes(group=building)) + 
  labs(y="Percentile (%)",x="KWH") +
  scale_y_continuous(breaks=seq(10,90,by=10)) + 
  facet_wrap(~dayWeek)
```
]

---

# Quantiles from long data

```{r, echo = FALSE, fig.width= 10, fig.height=5}
energy_long_quant %>%
  ggplot(aes(y = percentile, x = value, color=building)) +
  geom_point() + 
  geom_line(aes(group=building)) + 
  labs(y="Percentile (%)",x="KWH") +
  scale_y_continuous(breaks=seq(10,90,by=10)) + 
  facet_wrap(~dayWeek)
```

---
name: yourturn
template: section
class: action

# <i class="fa fa-pencil-square-o" style="font-size:48px;color:purple">&nbsp;Your&nbsp;Turn&nbsp;`r (yt <- yt + 1)`</i>    

.pull-left[
```{r, echo=FALSE, out.width='85%', fig.height=5, fig.width=4}
qdf <- energy %>% select(9:90) %>%
  map_dfc(quantile, probs = seq(.1,.9,.1), na.rm = TRUE) %>%  
  mutate(stat = str_c("quantile_", seq(10,90,10))) %>%   
  gather(key = building, value = q, 1:82)   

qdf %>% 
  filter(building %in% c("Sayles-Hill" ,"Language_&_Dining_Center", "Olin_Hall_of_Science"))  %>%  
  ggplot(aes(x=q, y=parse_number(stat), color=building)) +
  geom_point() + 
  geom_line(aes(group=building)) + 
  labs(y="Percentile (%)",x="KWH") +
  scale_y_continuous(breaks=seq(10,90,by=10))+
  theme(legend.position="bottom", legend.text = element_text(size=5), legend.title=element_text(size=8))

```
]
.pull-right[
.fancy[.font110[
Follow the prompts to plot the quantiles of energy consumption for the buildings `Sayles-Hill`, `Language_&_Dining_Center`, `Olin_Hall_of_Science`.]]
]


```{r echo=FALSE}
countdown(5)
```


