<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Case Study: Random Forest</title>
    <meta charset="utf-8" />
    <meta name="author" content="Bastola" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="libs/font-awesome/css/all.min.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.min.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <script src="https://use.fontawesome.com/5235085b15.js"></script>

    <link rel="stylesheet" href="css/xaringan-themer-solns.css" type="text/css" />
    <link rel="stylesheet" href="css/my-theme.css" type="text/css" />
    <link rel="stylesheet" href="css/my-font.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">











layout: true
  
---

class: title-slide, middle

# .fancy[Unlocking the Power of Machine Learning]
## .fancy[Address Formatting Correctness Prediction]
### .fancy[Spring 2023]

 May 29 2023

---


class: inverse, middle



.bql[# Example - Detecting Typos in Addresses
Consider the task of detecting typos in street addresses. A machine learning model could be trained to classify addresses as correct or incorrect based on various features, one of which could be the .b[Levenshtein distance] from a known correct address.
]


---

class: middle

# Examples of Addresses

.pull-left[
.bq.font80[
## Correct Addresses
1. 530 5th St E, Northfield, MN, 55057
2. 123 Main St, Los Angeles, CA, 90034
3. 789 Broadway, Apt 12B, New York, NY, 10025
4. 456 Pine Ave, San Francisco, CA, 94108
5. 159 River Rd, Boston, MA, 02115
]
]
.pull-right[
.bq.font80[## Incorrect Addresses
1. 530 5th Street East, North, MN, 55057
2. 123 Mian Street, Los Angeles, CA, 9003
3. 78 Broadway, Apt 12B, New York, NY, 10025
4. 456Pine Avenue, San Francisco, CA, 94108
5. 159 River Rd, Bosotn, MA, 02115
]
]


---

class: middle

# The Problem
## Incorrect and inconsistently formatted addresses

.pull-left[
.bql.font80[
- Inconsistently formatted addresses pose a significant problem in data management and analysis.
- They can lead to inaccurate data matching, ineffective communication, and inefficiencies in logistics and delivery services.
- Incorrect addresses can also pose security issues and lead to lost business opportunities.
]
]
.pull-right[
.bql.font80[
- Address standardization and validation is crucial in various domains such as e-commerce, logistics, healthcare, and public services.
- Data scientists often need to assess the validity of addresses, correct them where possible, or flag potential issues for further investigation.
]
]


.hljs[Our aim is to develop a machine learning model that can predict if a given address is correctly formatted based on various features.]

---

class: middle

# One Potential Solution: Random Forest for Address Formatting

.pull-left[
## Why Random Forest?
.bq.font80[
- .highlight[Ability to handle complex patterns]: Addresses can have diverse and complex patterns
- .highlight[Robust to overfitting]: The ensemble nature of Random Forest makes it less likely to overfit compared to simpler models
- .highlight[Feature importance]: Random Forest provides a straightforward way to measure the importance of each feature
]
]


.pull-right[
## Training Random Forest
.bq.font80[
- The Random Forest model is trained using our dataset, which contains both correctly and incorrectly formatted addresses.
- Each address is represented by a set of features such as its length, number of words, presence of apartment number, zip code correctness, etc.
- Our model learns to predict the correctness of an address based on these features.
]
]

---

class: middle

# Feature and Feature Engineering

.pull-left[

.bql[
"Length"               
"Number of Words"      
"State Code"          
"Zip Code"           
"Levenshtein Distance"  
"Presence of apt no"    
"Presence of street no"   
]

]

.pull-right[
.bql[

"Presence of street name" 
"Presence of city"      
"Presence of state"     
"Presence of zip code"   
"State code correctness" 
"Zip code correctness"
"Typo in street name" 

]


]




---

class: middle

#  Levenshtein distance

.hljs[Levenshtein distance is a tool used for quantifying the difference between two sequences by calculating the minimum number of single-character edits needed to transform one string into the other.]

.bqt.font80[

- This measure utilizes three types of edits: insertions, deletions, and substitutions.

- Due to its ability to assess string similarity and difference, Levenshtein distance finds extensive use in applications where such determinations are necessary.
]


.footnote[Levenshtein, Vladimir I. "Binary codes capable of correcting deletions, insertions, and reversals." In Soviet physics doklady, vol. 10, no. 8, pp. 707-710. 1966.]

---

class: middle

# Calculation of Levenshtein Distance

.hljs[Let's consider two strings: kitten and sitting. To transform "kitten" into "sitting" we could:]

.bql.font90[
- Substitute "k" with "s" - sitting
- Substitute "e" with "i" - sittin
- Append "g" - sitting
]

.blue-h[The Levenshtein distance between "kitten" and "sitting" is therefore 3.]

---


class: middle

# R code for calculating Levenshtein Distance for Address Validation



```r
# Calculate the Levenshtein distance between the provided and correct address
levenshtein_distance &lt;- stringdist::stringdist(address, correct_address)
```


---

class: middle

# Other examples

In addition to address validation, the Levenshtein distance can be used in a wide range of other applications. 

.bq.font90[
- DNA sequence alignment in bioinformatics
- Spell checking and correction
- Duplicate detection in data cleaning.
]

---

class: action, middle

# &lt;i class="fa fa-pencil-square-o" style="font-size:48px;color:purple"&gt;&amp;nbsp;Group&amp;nbsp;Activity&amp;nbsp;1&lt;/i&gt;    


.pull-left-40[
![](https://media.giphy.com/media/RKApDdwsQ6jkwd6RNn/giphy.gif)
]
.pull-right-60[
&lt;br&gt;
.bq[
- Get the class activity 27.Rmd file from  [moodle](https://moodle.carleton.edu/course/view.php?id=39491) 
- Let's work on group activity 1 together
]

]

<div class="countdown" id="timer_72edb5ca" data-update-every="1" tabindex="0" style="top:0;right:0;padding:3px 4px;font-size:2em;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">20</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"highlightLanguage": ["r", "css", "yaml"],
"countIncrementalSlides": true,
"slideNumberFormat": "%current%",
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
