<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Regression</title>
    <meta charset="utf-8" />
    <meta name="author" content="Bastola" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <script src="https://use.fontawesome.com/5235085b15.js"></script>

    <link rel="stylesheet" href="css/xaringan-themer-solns.css" type="text/css" />
    <link rel="stylesheet" href="css/my-theme.css" type="text/css" />
    <link rel="stylesheet" href="css/my-font.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">







layout: true
  
&lt;!-- &lt;div class="my-footer"&gt;&lt;span&gt;Bastola&lt;/span&gt;&lt;/div&gt; --&gt;
&lt;!-- this adds the link footer to all slides, depends on my-footer class in css--&gt;

---

class: title-slide, middle
&lt;!-- background-image: url("assets/title-image2.jpg") --&gt;
background-position: 10% 90%, 100% 50%
background-size: 160px, 100% 100%

# .fancy[Intro to Clustering]

### .fancy[Stat 220]

.large[Bastola]

 March 04 2022

---

# Supervised to unsupervised

.pull-left[
&lt;img src="Day23_files/figure-html/unnamed-chunk-1-1.svg" width="100%" style="display: block; margin: auto;" /&gt;

]
.pull-right[
&lt;img src="Day23_files/figure-html/unnamed-chunk-2-1.svg" width="100%" style="display: block; margin: auto;" /&gt;

]


---

class: middle

# K-means Basics

- Algorithm to group data into K clusters

- Starts with an initial clustering of data

- Iteratively improves the cluster assignments 

- Stops until the assignments cannot be improved further

---

class: middle

# Algorithm

1. Randomly assign a number, from 1 to K, to each of the observations

2. Compute the centroid of each of the K clusters

3. Assign each point to the nearest centroid and redefine the cluster

4. Repeat steps 2 and 3 until no point change clusters

---

# Main Idea

&gt; To minimize the total within cluster variation

The total within-cluster variation is the sum of squared Euclidean distances between items and the corresponding centroid:

`$$W = \sum_{k=1}^K W(C_k) = \sum_{k=1}^K \sum_{x_i \in C_k}(x_i - \mu_k)^2$$`
where:

- `\(x_i\)` is a data point in the cluster `\(C_k\)`

- `\(\mu_k\)` is the mean value of the points assigned to the cluster `\(C_k\)`

---

.bold[Randomly assign a number, from 1 to *K* , to each of the observations]

&lt;img src="Day23_files/figure-html/unnamed-chunk-3-1.svg" width="600" style="display: block; margin: auto;" /&gt;


---

.bold[Compute the centroid of each cluster]

&lt;img src="Day23_files/figure-html/unnamed-chunk-4-1.svg" width="600" style="display: block; margin: auto;" /&gt;


---

.bold[Re-assign each observation to the cluster whose centroid is closest]

&lt;img src="Day23_files/figure-html/unnamed-chunk-5-1.svg" width="600" style="display: block; margin: auto;" /&gt;

---

.bold[Re-compute the centroid of each cluster]

&lt;img src="Day23_files/figure-html/unnamed-chunk-6-1.svg" width="600" style="display: block; margin: auto;" /&gt;


---

.bold[Re-assign each observation to the cluster whose centroid is closest]

&lt;img src="Day23_files/figure-html/unnamed-chunk-7-1.svg" width="600" style="display: block; margin: auto;" /&gt;


---

.bold[Re-compute the centroid of each cluster]

&lt;img src="Day23_files/figure-html/unnamed-chunk-8-1.svg" width="600" style="display: block; margin: auto;" /&gt;


---

.bold[Re-assign each observation to the cluster whose centroid is closest]

&lt;img src="Day23_files/figure-html/unnamed-chunk-9-1.svg" width="600" style="display: block; margin: auto;" /&gt;


---

.bold[Re-compute the centroid of each cluster]

&lt;img src="Day23_files/figure-html/unnamed-chunk-10-1.svg" width="600" style="display: block; margin: auto;" /&gt;


---

.bold[Re-assign each observation to the cluster whose centroid is closest]

&lt;img src="Day23_files/figure-html/unnamed-chunk-11-1.svg" width="600" style="display: block; margin: auto;" /&gt;


---

.bold[Re-compute the centroid of each cluster]

&lt;img src="Day23_files/figure-html/unnamed-chunk-12-1.svg" width="600" style="display: block; margin: auto;" /&gt;

---

# `USArrests`


```r
USAData &lt;- as_tibble(USArrests, rownames = "state") %&gt;% na.omit() %&gt;%
  column_to_rownames("state") %&gt;%
  select(Murder, UrbanPop)
```


```r
head(USAData, 10)
            Murder UrbanPop
Alabama       13.2       58
Alaska        10.0       48
Arizona        8.1       80
Arkansas       8.8       50
California     9.0       91
Colorado       7.9       78
Connecticut    3.3       77
Delaware       5.9       72
Florida       15.4       80
Georgia       17.4       60
```

---

# Means and standard deviations


```r
USAData %&gt;%
  map_dfr(mean)
# A tibble: 1 × 2
  Murder UrbanPop
   &lt;dbl&gt;    &lt;dbl&gt;
1   7.79     65.5
```

--


```r
USAData %&gt;%
  map_dfr(sd)
# A tibble: 1 × 2
  Murder UrbanPop
   &lt;dbl&gt;    &lt;dbl&gt;
1   4.36     14.5
```

---

# Standardize the data

&lt;!-- Don't want the clustering algorithm to depend to an arbitrary variable unit --&gt;


```r
USAData &lt;- USAData %&gt;% mutate(across(where(is.numeric), standardize))
```


```r
head(USAData,10)
                 Murder   UrbanPop
Alabama      1.24256408 -0.5209066
Alaska       0.50786248 -1.2117642
Arizona      0.07163341  0.9989801
Arkansas     0.23234938 -1.0735927
California   0.27826823  1.7589234
Colorado     0.02571456  0.8608085
Connecticut -1.03041900  0.7917228
Delaware    -0.43347395  0.4462940
Florida      1.74767144  0.9989801
Georgia      2.20685994 -0.3827351
```


---

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="Day23_files/figure-html/unnamed-chunk-19-1.svg" alt="Euclidean Distances" width="60%" /&gt;
&lt;p class="caption"&gt;Euclidean Distances&lt;/p&gt;
&lt;/div&gt;


---

class: inverse, middle

# So, how do we fit all of this in R?

---

class: middle

# `kmeans()`

- `kmeans()` function takes a matrix or data-frame or tibble and the number of centers/clusters we want to find.

- We also set `nstart = 20-25` to have multiple initial starting positions in the hope of finding global optimal solution instead of local optimal solution

- Use `set.seed()` for reproducibility
---

class: middle

# Within Cluster Sum of Squared Errors (WSS)

- Calculate WSS for different values of K.

- Choose K for which WSS first starts to diminish.

- Visually deciphered with an .bold[elbow graph].

- The number of clusters is taken at the elbow joint point.

---

class: middle

# K-means


```r
set.seed(1234)
k.means &lt;- kmeans(USAData, centers = 2, nstart = 25)
```

---

class: middle


```r
k.means %&gt;% tidy()
# A tibble: 2 × 5
  Murder UrbanPop  size withinss cluster
   &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt;    &lt;dbl&gt; &lt;fct&gt;  
1  0.896    0.194    23     31.6 1      
2 -0.763   -0.165    27     30.6 2      
```

---

class: middle


```r
glance(k.means)
# A tibble: 1 × 4
  totss tot.withinss betweenss  iter
  &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;
1    98         62.2      35.8     1
```

---

# `augment` from `broom` package


```r
augment(k.means, data = USAData)
# A tibble: 50 × 4
   .rownames    Murder UrbanPop .cluster
   &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;   
 1 Alabama      1.24     -0.521 1       
 2 Alaska       0.508    -1.21  1       
 3 Arizona      0.0716    0.999 1       
 4 Arkansas     0.232    -1.07  2       
 5 California   0.278     1.76  1       
 6 Colorado     0.0257    0.861 1       
 7 Connecticut -1.03      0.792 2       
 8 Delaware    -0.433     0.446 2       
 9 Florida      1.75      0.999 1       
10 Georgia      2.21     -0.383 1       
# … with 40 more rows
```

---

&lt;img src="Day23_files/figure-html/unnamed-chunk-24-1.svg" width="70%" style="display: block; margin: auto;" /&gt;

---

# In-built function for visuals

.code80[

```r
library(factoextra)
fviz_cluster(k.means, data = USAData, repel = TRUE)
```

&lt;img src="Day23_files/figure-html/unnamed-chunk-25-1.svg" width="55%" style="display: block; margin: auto;" /&gt;
]

---

&lt;img src="Day23_files/figure-html/unnamed-chunk-26-1.svg" width="75%" style="display: block; margin: auto;" /&gt;


---

class: middle

# Visuals do not tell all the story

&gt; Visuals tell us where the true delineations occur, but do not tell us what the optimal number of clusters is.

---

# Determine the optimal number of clusters

.code80[

```r
set.seed(1234)
multi_kmeans &lt;- tibble(k = 1:10) %&gt;%
  mutate(
    model = purrr::map(k, ~ kmeans(USAData, centers = .x, nstart = 25)),
    tot.withinss = purrr::map_dbl(model, ~ glance(.x)$tot.withinss)
  )

multi_kmeans
# A tibble: 10 × 3
       k model    tot.withinss
   &lt;int&gt; &lt;list&gt;          &lt;dbl&gt;
 1     1 &lt;kmeans&gt;        98   
 2     2 &lt;kmeans&gt;        62.4 
 3     3 &lt;kmeans&gt;        36.6 
 4     4 &lt;kmeans&gt;        24.9 
 5     5 &lt;kmeans&gt;        19.6 
 6     6 &lt;kmeans&gt;        16.4 
 7     7 &lt;kmeans&gt;        13.7 
 8     8 &lt;kmeans&gt;        11.0 
 9     9 &lt;kmeans&gt;         9.85
10    10 &lt;kmeans&gt;         8.04
```
]

---

&lt;img src="Day23_files/figure-html/unnamed-chunk-28-1.svg" width="75%" style="display: block; margin: auto;" /&gt;

---

&lt;img src="Day23_files/figure-html/unnamed-chunk-29-1.svg" width="75%" style="display: block; margin: auto;" /&gt;

---

# Extract 


```r
USAData %&gt;%
  mutate(Cluster = kmeans.final$cluster) %&gt;%
  group_by(Cluster) %&gt;%
  summarise_all("mean")
# A tibble: 4 × 3
  Cluster Murder UrbanPop
    &lt;int&gt;  &lt;dbl&gt;    &lt;dbl&gt;
1       1  0.649    0.941
2       2 -0.606    0.412
3       3  1.22    -0.866
4       4 -1.09    -1.22 
```


---

class: action

# &lt;i class="fa fa-pencil-square-o" style="font-size:48px;color:purple"&gt;&amp;nbsp;Your&amp;nbsp;Turn&amp;nbsp;1&lt;/i&gt;    

Please clone the repository on [clustering](https://github.com/stat220/22-clustering) to your local folder.

&lt;img src="Day23_files/figure-html/unnamed-chunk-31-1.svg" width="45%" style="display: block; margin: auto;" /&gt;

Complete the questionnaires to find the optimal number of clusters using the total within sum of squares criteria.

<div class="countdown" id="timer_62225c85" style="top:0;right:0;padding:3px 4px;font-size:2em;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>


---

class: middle

# Hierarchical clustering

- A method used to group objects based on similarity

- Focus on agglomerative hierarchical clustering (bottom-up approach)

- To form an attractive tree-based representation of the observations called .bold[dendogram]

- Flexible cut-off choice for the number of clusters 

---

class: middle

# Algorithm

1. Starts by calculating the distance between every pair of observation points and store it in a distance matrix.
2. Puts every point in its own cluster.
3. Starts merging the closest pairs of points based on the distances from the distance matrix and as a result the amount of clusters goes down by 1.
4. Recomputes the distance between the new cluster and the old ones and stores them in a new distance matrix.
5. Repeats steps 2 and 3 until all the clusters are merged into one single cluster.


---

# Dissimilarity values


```r
d &lt;- dist(USAData, method = "euclidean")
```

--

# Agglomeration method


```r
# Hierarchical clustering
hc1 &lt;- hclust(d)
```

--

# Plot the dendogram


```r
# Plot the obtained dendrogram
plot(hc1, cex = 0.6, hang = -1)
```

---

&lt;img src="Day23_files/figure-html/unnamed-chunk-35-1.svg" width="75%" style="display: block; margin: auto;" /&gt;

---

class: middle


```r
# Cut tree into 4 groups
sub_grp &lt;- cutree(hc1, k = 4)
```


```r
# Number of members in each cluster
table(sub_grp)
sub_grp
 1  2  3  4 
 7 17 13 13 
```

---

class: middle


```r
USAData %&gt;%
  mutate(cluster = sub_grp) %&gt;%
  head()
               Murder   UrbanPop cluster
Alabama    1.24256408 -0.5209066       1
Alaska     0.50786248 -1.2117642       2
Arizona    0.07163341  0.9989801       3
Arkansas   0.23234938 -1.0735927       2
California 0.27826823  1.7589234       3
Colorado   0.02571456  0.8608085       3
```


---
.code70[

```r
plot(hc1, cex = 0.6)
rect.hclust(hc1, k = 4, border = 2:5)   # Number of clusters
```
]

&lt;img src="Day23_files/figure-html/unnamed-chunk-40-1.svg" width="65%" style="display: block; margin: auto;" /&gt;

---

.code70[

```r
plot(hc1, cex = 0.6)
rect.hclust(hc1, h = 2, border = 2:5)   # Height of branch
```
]

&lt;img src="Day23_files/figure-html/unnamed-chunk-42-1.svg" width="65%" style="display: block; margin: auto;" /&gt;

---

class: action

# &lt;i class="fa fa-pencil-square-o" style="font-size:48px;color:purple"&gt;&amp;nbsp;Your&amp;nbsp;Turn&amp;nbsp;2&lt;/i&gt;    

&lt;img src="Day23_files/figure-html/unnamed-chunk-43-1.svg" width="55%" style="display: block; margin: auto;" /&gt;

Explore further about hierarchical clustering using the instructions provided to produce the dendogram above.

<div class="countdown" id="timer_62225a7a" style="top:0;right:0;padding:3px 4px;font-size:2em;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"highlightLanguage": ["r", "css", "yaml"],
"countIncrementalSlides": true,
"slideNumberFormat": "%current%",
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
(function(time) {
  var d2 = function(number) {
    return ('0' + number).slice(-2); // left-pad 0 to minutes/seconds
  },

  time_format = function(total) {
    var secs = Math.abs(total) / 1000;
    var h = Math.floor(secs / 3600);
    var m = Math.floor(secs % 3600 / 60);
    var s = Math.round(secs % 60);
    var res = d2(m) + ':' + d2(s);
    if (h > 0) res = h + ':' + res;
    return res;  // [hh:]mm:ss
  },

  slide_number_div = function(i) {
    return document.getElementsByClassName('remark-slide-number').item(i);
  },

  current_page_number = function(i) {
    return slide_number_div(i).firstChild.textContent;  // text "i / N"
  };

  var timer = document.createElement('span'); timer.id = 'slide-time-left';
  var time_left = time, k = slideshow.getCurrentSlideIndex(),
      last_page_number = current_page_number(k);

  setInterval(function() {
    time_left = time_left - 1000;
    timer.innerHTML = ' ' + time_format(time_left);
    if (time_left < 0) timer.style.color = 'red';
  }, 1000);

  slide_number_div(k).appendChild(timer);

  slideshow.on('showSlide', function(slide) {
    var i = slide.getSlideIndex(), n = current_page_number(i);
    // reset timer when a new slide is shown and the page number is changed
    if (last_page_number !== n) {
      time_left = time; last_page_number = n;
      timer.innerHTML = ' ' + time_format(time); timer.style.color = null;
    }
    slide_number_div(i).appendChild(timer);
  });
})(60000);
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
